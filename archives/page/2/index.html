
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jim Wang">
    <title>归档 - Jim Wang</title>
    <meta name="author" content="Jim Wang">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.png">
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{}</script>
    <meta name="description" content="ssss">
<meta property="og:type" content="blog">
<meta property="og:title" content="Jim Wang">
<meta property="og:url" content="http://yoursite.com/archives/page/2/index.html">
<meta property="og:site_name" content="Jim Wang">
<meta property="og:description" content="ssss">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Jim Wang">
<meta name="twitter:card" content="summary">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/avater.png"/>
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-lbwyo1qxpg1hpfggd0e8dvssxoutmxxszfevq18hnlk7wrvazw0lfy2esysn.min.css">

    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-172143513-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-172143513-1');
    </script>


    
    <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1d51896cc9cd82561c7c8e353bb78c0d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>


    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/%20"
            aria-label=""
        >
            Jim Wang
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avater.png" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avater.png" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">Jim Wang</h4>
                <h5 class="sidebar-profile-subtitle"><p>个人技术博客</p>
</h5>
                
                    <h5 class="sidebar-profile-bio"> <hr style='margin: 5px auto; border-top: 1px solid rgba(255,255,255,0.14); width: 20%;'> <span>全栈探索之路<span> <hr style='margin: 8px auto; border-top: 1px solid rgba(255,255,255,0.14); width: 60%;'> 记录个人对技术的理解和开发过程中遇到的问题，欢迎了解更多。 </h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/zicowarn"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#wechat"
                            
                            rel="noopener"
                            title="微信公众号"
                        >
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/zuiwuxin?s=09"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/zhichao-wang-a16662109"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="领英"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">领英</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:zicowarn@hotmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/10/0803-ma-dynamic-classmethod-override/"
                            aria-label=": Python 杂记之 如何动态重写类方法"
                        >
                            Python 杂记之 如何动态重写类方法
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-10T08:11:08+08:00">
	
		    12月 10, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/">Python 相关 - 8. Python 杂记</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<h2 id="Python-是动态的编程语言"><a href="#Python-是动态的编程语言" class="headerlink" title="Python 是动态的编程语言"></a>Python 是动态的编程语言</h2><p> 在自己有关Python的第一篇文章中就介绍了Python的特性与优势，在文章中也介绍了其是一种动态的编程语言。在这里我再简单在当前文章中介绍一下，如下：</p>
<blockquote>
<p>能够在运行时修改自身程序结构的语言，就属于动态语言。那怎样才算是“运行时修改自身程序结构”捏？比如下面这几个例子都 算：在运行时给某个类增加成员函数及成员变量；在运行时改变某个类的父类；在运行时创建出某个函数.。 Python是可以实现动态类的创建类（在任意代码位置，符合正确的书写格式），或者给类增加删除属性。因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。比如，你可以在函数中创建类，使用class关键字即可。” 既然是一种动态的高级语言，那么就意味着，其是在运行时就能改变其结构的编程语言。这在调试代码时，可以动态实时地改变变量，重写函数等，比起传统的C++与广泛运用的Java具有很强的优势。所叙述的结构包括：函数、变量与对象。已有的函数或方法可以被删除或是其他结构上的变化。</p>
</blockquote>
<h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p> 最近在工作中遇到了一个问题：现有一Wxpython的Widget类，即继承TextCtrl的自定义类，该类有一个实例方法，在这暂且就称作method_x吧，整个项目都在使用该实例方法，虽然其内在调用关系十分复杂，这也是我一直诟病我们项目代码的地方，但其一直表现良好。我的需求是：在不改变这个类的，也不影响其他代码的的情况下，重写或者重新定义这个方法。这些只并且仅对特定实例有效。</p>
<p> 首先我能想到的就是继承该类，进而得到一个子类，在子类里面仅Override覆盖该实例方法。这应该是最正常的方法，或者大部分人能想到的方法。可是我又不希望这样做，这样在后期维护的该类的时候还要为子类针对一下改变做出调整。而且在文章中还要import一下。那么有没有别的方法呢？考虑到Python是动态语言，动态调整函数和变量都是自己应用过的，那么这样的动态语言，能不能动态地修改（重写）一个类的实例方法呢？抱着这样的想法，我查阅了一些网页，成功实现了这样的想法，也在完成该任务，解决该问题的过程中更深层的理解了Python这种语言的动态特性。</p>
<p> 最终我归纳出三种方法，可以实现类的实例方法的动态重写，在此我针对每种方法列出范例代码，并给出运行结果，并对这三种方法进行比较说明，本人并非专家，有见解不足之处，也希望各位高手留言赐教。</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p> 使用函数的_<em>get()__内置方法，也是一个描述符，其本质是一个新式类, 在这个新式类中, 至少实现了<em>\</em>_get()_\</em>, __set()__, <em>\</em>delete()__中的一个, 这也被称为描述符协议，其中__get()<em>\</em>:在调用一个属性时被触发。 __get__(self, instance, owner) 定义当描述器的值被取得的时候的行为， instance 是拥有者对象的一个实例。 owner 是拥有者类本身。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am old func1"</span>        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func1</span><span class="params">(self)</span>:</span>        </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am new func1"</span></span><br><span class="line"></span><br><span class="line">objTest1 = Test()</span><br><span class="line"><span class="keyword">print</span> id(new_func1)</span><br><span class="line">objTest2 = Test()</span><br><span class="line">objTest1.func1()</span><br><span class="line">objTest2.func1() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅对该实例重写这个方法</span></span><br><span class="line"><span class="keyword">print</span> new_func1.__get__(objTest1, Test)</span><br><span class="line">objTest1.func1 = new_func1.__get__(objTest1, Test)</span><br><span class="line">objTest1.func1()</span><br><span class="line">objTest2.func1()</span><br></pre></td></tr></table></figure>

<p>代码输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\\&gt;python test.py</span><br><span class="line">55131384</span><br><span class="line">I am old func1</span><br><span class="line">Iam old func1</span><br><span class="line">&lt;bound method Test.new_func1 of &lt;__main__.Test instance at 0x0000000002F60C88&gt;&gt;</span><br><span class="line">I am new func1</span><br><span class="line">I am old func1</span><br></pre></td></tr></table></figure>

<p>那么现在我们来尝试来理解一下这个方法的原理，上文说到__get()__是一个描述符，或称描述器，描述器分为两种，一共是资料描述器（data-descriptor), 一种是非资料描述器(non-data descriptor)。我们在这里使用的是非资料描述器， __get__(self, instance, owner) ，该方法的第二个参数是可选的（非必需）。 上面代码在使用该描述器的时候，就是将函数new_func1()绑定在类Test的实例objTest1上，而等号前面的是objTest1.func1 意味这，要将新绑定的实例方法覆盖到func1上，进而在再次调用实例方法func1()的时候，其实是在调用new_func1()。 该方法很有好处，可以理解为”几乎”是实现了一个方法的覆盖，你可以在新定义的方法中使用关键字self。 但是不能使用关键字super，即不能访问类的父类。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用Python的偏函数，Python的偏函数，与数学意义上的偏函数不同。其偏函数的思想可以理解为绑定了一部分参数的函数，其作用就是减少传入函数，使函数更短，更简洁。在这儿使用偏函数重写实例方法，目的就在与保证第一个参数self的传入。也就是partial()的第二个参数。把new_func1()的第一个参数固定了下来。保证重写的实例方法能访问self关键字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.m = <span class="string">"message"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am old func1"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func1</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> self.m</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am new func1"</span></span><br><span class="line"></span><br><span class="line">objTest1 = Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(new_func1)</span><br><span class="line"></span><br><span class="line">objTest2 = Test()</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅对该实例重写这个方法</span></span><br><span class="line"><span class="comment">#print new_func1.__get__(objTest1, Test)</span></span><br><span class="line"><span class="comment">#objTest1.func1 = new_func1.__get__(objTest1, Test)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line">objTest1.func1 = partial(new_func1, objTest1)</span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\\&gt;python test.py</span><br><span class="line">52313336</span><br><span class="line">I am old func1</span><br><span class="line">I am old func1</span><br><span class="line">47500528</span><br><span class="line">47692840</span><br><span class="line">message</span><br><span class="line">I am new func1</span><br><span class="line">I am old func1</span><br></pre></td></tr></table></figure>

<p>该种方法也简单有效，但是也要从functool中引入partial。也算是一种有效的解决方案。但是其也不能访问关键字super。输出的结果也显示，这样的改变只对特定实例有效。我个人觉得这也是一个简单容易理解的方法，相比较方法一而言，其原理理解起来也并不困难。也不需要更深层次的Python理论知识。</p>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>使用types包中的MethodType 函数。这个方法理解起来就相对更为简单。MethodType可以将一个函数绑定在特定的实例，或者类上。而且该类或者实例，可以没有方法，如果有相同名字的方法，就视为重写。如果绑定在实例上，则完全覆盖其实例的方法。如果绑定在类上，则对所有实例有效。两个绑定方法的区别就在与函数的第二个参数上。 MethodType把方法绑定在类实例上时，每个实例有自己单独的指向区域，互不干扰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="comment">#from functools import partial</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.m = <span class="string">"message"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am old func1"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func1</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> self.m</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am new func1"</span></span><br><span class="line"></span><br><span class="line">objTest1 = Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(new_func1)</span><br><span class="line"></span><br><span class="line">objTest2 = Test()</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1() </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line"><span class="comment"># 仅对该实例重写这个方法</span></span><br><span class="line"><span class="comment">#print new_func1.__get__(objTest1, Test)</span></span><br><span class="line"><span class="comment">#objTest1.func1 = new_func1.__get__(objTest1, Test)</span></span><br><span class="line"><span class="comment">#objTest1.func1 = partial(new_func1, objTest1)</span></span><br><span class="line"></span><br><span class="line">objTest1.func1 = types.MethodType(new_func1, objTest1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\\&gt;python test.py</span><br><span class="line">60046584</span><br><span class="line">I am old func1</span><br><span class="line">I am old func1</span><br><span class="line">55233776</span><br><span class="line">55233776</span><br><span class="line">message</span><br><span class="line">I am new func1</span><br><span class="line">I am old func1</span><br></pre></td></tr></table></figure>

<p>从上面的输出结果来看，时候该方法重写实例方法的时候，实例方法的id也没有改变，这是完全意义上方法重写，使用该方法重写类的实例方法，可以访问类的所有关键字。该方法绑定类方法时有一个很有趣区别，因为并不是当前任务需要，这些内容，我们以后在别的文章中进行讨论。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>三种方法以三个不同方向，三种不同的Python背景知识诠释了如何动态的重写（或绑定）一个实例的方法。在分析利弊与结合自己的使用需求，我个人最终选择了方法三, 每种方法都有自己的优缺点，比如方法一就不需要引入别的Python模块。但是至于那个方法是最优的解决方法，那应该是仁者见仁智者见智。这样的经历也是在自己在解决问题的过程中常常经历的。不断地思考探究，也能扎实自己的理论知识，向大拿高手学习的过程中，也为自己在以后遇见问题是，扩展了思考方向。让自己不断拷问自己，同样的需求是不是还有别的解决方案。然后探究，学习，尝试，掌握。 上述内容实自己总结归纳的，总有不足之处，望见谅并指正。</p>
<p>参考目录：</p>
<p><strong>Stackoverflow：</strong> <a href="https://stackoverflow.com/questions/394770/override-a-method-at-instance-level" target="_blank" rel="noopener">https://stackoverflow.com/questions/394770/override-a-method-at-instance-level</a></p>
<p><strong>CSDN Blog:</strong> [<a href="https://blog.csdn.net/yuanyangsdo/article/details/60776612]" target="_blank" rel="noopener">https://blog.csdn.net/yuanyangsdo/article/details/60776612]</a>(</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/10/0803-ma-dynamic-classmethod-override/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/05/0802-ma-file-extension/"
                            aria-label=": Python 杂记之 文件扩展名的区别"
                        >
                            Python 杂记之 文件扩展名的区别
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-05T08:11:08+08:00">
	
		    12月 05, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/">Python 相关 - 8. Python 杂记</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a><strong>导语</strong></h2><p>虽然Python简单并且容易部署，平时开发时，除了常见的py和pyc文件后缀以外，其实python还有一些别的文件扩展名。我们这篇文章就归纳总结一下所有的与python相关的文件扩展名filename extension（又称后缀名）与各种文件扩展名的文件是如何产生，每种文件文件扩展名的作用。</p>
<h2 id="与Python有关扩展名"><a href="#与Python有关扩展名" class="headerlink" title="与Python有关扩展名"></a><strong>与Python有关扩展名</strong></h2><ul>
<li><strong>.py</strong> - 最基本的文件扩展名</li>
<li><strong>.py3</strong> - (极其少见) Python3 源码文件扩展名. Python3 的正式源码后缀名也为”.py” 不是 “.py3”, 但py3也曾在一些地方出现。</li>
<li><strong>.pyc</strong> - 源码编译过的文件的扩展名 (字节码)。</li>
<li><strong>.pyo</strong> - 与pyc一样也是编译过的文件的文件扩展名。优化编译后的程序（相比于.pyc文件更小），也可以提高加载速度。对于嵌入式系统，它可将所需模块编译成.pyo文件以减少容量需求。</li>
<li><strong>.pyw</strong> - 和py相似，是源码扩展名，跟py扩展名的区别是在windows下双击pyw扩展名的源码会调用pythonw.exe执行源码，这种执行方式不会有命令行窗口，用于GUI程序发布时不需要看到控制台信息的情况。linux环境中，pyw和pyc没有区别。</li>
<li><strong>.pyx</strong> - Cython 源码，与C/C++源码.c/.cpp相似，不像 Python 语言可直接解释使用的 .py 文件，.pyx 文件必须先被编译成 .c 文件，再编译成 .pyd (Windows 平台) 或 .so (Linux 平台) 文件，才可作为模块 import 导入使用。</li>
<li><strong>.pyd</strong> - pyd并非从python程序生成，而是其他语言写成的可以被python调用的扩展，例如C++写的（Windows平台dll，Linux 平台.so）动态连接库供python调用。</li>
<li><strong>.pxd</strong> - Cython 源码头文件，与C/C++源码.h相似。pxd 文件中有 Cython 模块要包含的 Cython 声明 (或代码段)。.pxd 文件可共享外部 C 语言声明，也能包含 C 编译器内联函数。.pxd 文件还可为 .pyx 文件模块提供 Cython 接口，以便其它 Cython 模块可使用比 Python 更高效的协议与之进行通信。可用 cimport 关键字将 .pxd 文件导入 .pyx 模块文件中。</li>
<li><strong>.pxi</strong> - MyPy存根。</li>
<li><strong>.pyi</strong> - 存根文件，替代.pxi。 (参考：PEP 484)，如果想在Python编译时实现类型检查，需要用MyPy。 MyPy包含生成.pyi文件的stubgen.py工具。</li>
<li><strong>.pyz</strong> - Python脚本归档<strong>（参考：PEP 441)</strong>（这是一个包含标准Python脚本头之后的二进制形式的压缩Python脚本（ZIP）的脚本）</li>
<li><strong>.pywz</strong> - 用于MS-Windows的Python脚本归档<strong>（**</strong>参考：PEP 441)**，如上.pyz。</li>
<li><strong>.py[cod]</strong> - 版本管理工具Git的忽略文件.gitignore中的通配符，表示需要忽略的文件可能是.pyc，.pyo或.pyd。</li>
<li><strong>.rpy</strong>- 包含应用程序或框架特定功能的RPython脚本或Python脚本</li>
<li><strong>.pyde</strong> - 处理使用的Python脚本</li>
<li><strong>.pyp</strong> - Py4D Python插件</li>
<li><strong>.pyt</strong> - Python 工具箱 (.pyt) 只是一个基于 ASCII 的文件，该文件定义了工具箱和一个或多个工具。<strong>（参**</strong>考：ArcGIS)**</li>
</ul>
<h2 id="扩展名相互关系"><a href="#扩展名相互关系" class="headerlink" title="扩展名相互关系"></a><strong>扩展名相互关系</strong></h2><p>大部分情况下，我们创建的Python脚本都是以.py为文件扩展名。py文件可以通过python命令或者自己写的py脚本进行编译成pyc。使用命令的方法如下，在cmd输入以下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m py_compile &#x2F;path&#x2F;to&#x2F;mycode.py #若批量处理.py文件</span><br><span class="line">                                        #则替换为&#x2F;path&#x2F;to&#x2F;&#123;需要生成.pyc的文件1,文件2,...&#125;.py</span><br><span class="line">                                        #或者&#x2F;path&#x2F;to&#x2F;</span><br></pre></td></tr></table></figure>

<p>也可以在python文件中实现上述过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于文件                                                      </span></span><br><span class="line"><span class="keyword">import</span> py_compile  </span><br><span class="line">py_compile.compile(<span class="string">r'/path/to/mycode.py'</span>) <span class="comment">#.py文件             </span></span><br><span class="line"><span class="comment">#此处尽可能使用raw字符串，从而避免转义的麻烦。                        </span></span><br><span class="line"><span class="comment">#比如，这里不加“r”的话，你就得对斜杠进行转义  #对于文件夹                                                     </span></span><br><span class="line"><span class="keyword">import</span> compileall                                            </span><br><span class="line">compileall.compile_dir(<span class="string">"mylib"</span>, force=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>当然如果希望生成.pyo，则可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -O -m py_compile &#x2F;path&#x2F;to&#x2F;mycode.py #文件或者目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-O选项，将.pyc文件优化为.pyo文件，而不是将.py 文件优化编译为.pyo文件。优化编译后的文件略微小于.pyc文件， 减少储存的需求。</p>
</blockquote>
<p>编译过后的字节码文件.pyc可以反编译成.py文件。反编译软件叫Easy Python Decompiler，可以从网上自己下载，该工具很容易上手，可以反编译一个文件也可以是文件夹。</p>
<p>虽然编译过后的二进制的字节码可以被反编译。但是如果你不希望自己的代码被别人直接读取，那么可以将字节码.pyc文件打包并公布。虽然与Python的开源精神不相符，但是也算是折中的安全机制。但是值得注意的是：.pyc文件与Python的版本有依赖。即，如果你用Python X编译的pyc文件不能再Python Y中使用，这里的X，Y为代指某些版本，无特定意义。如果强制加载将会引发ImportError异常，异常关键字为Bad magic Number。</p>
<p>下列是部分版本的Magic Number，全部列表请（参考：<strong>Magic_Nr</strong>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.5b3: 62111</span><br><span class="line">2.5c1: 62121</span><br><span class="line">2.5c2: 62131</span><br><span class="line">2.6a0: 62151</span><br><span class="line">2.6a1: 62161</span><br><span class="line">2.7a0: 62171</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>Python 3.x 的编译过程是与Python2.x 有区别的，Python 3.x 编译的pyc的时候，会在当前目录里生成一个名为<strong>pycache</strong>的文件夹，为什么会存在该文件夹？Python解释器会将 <em>.py 脚本文件进行编译，并将编译结果保存到<strong>pycache</strong>目录中。下次再执行时，如果解释器发现某个</em> .py 脚本没有修改过，就会跳过编译这一步，直接运行以前生成的保存在 <strong>pycache</strong>文件夹里的 *.pyc 文件。这样就可以大大缩短项目运行前的准备时间；如果你只需执行一个小工程，没关系 忽略这个文件夹就行。而此时你打包pyc的时候就会发现该文件不能正常地被加载，会提示一些错误，常见的错误是解释器和文件路径不匹配。</p>
<p>为了避免上述的问题，我们可以在编译的时候输入特定的参数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m compileall -b test3</span><br></pre></td></tr></table></figure>

<p>选项-b，指定编译pyc文件的输出到它们的原始位置。（即与Python2中相同）。</p>
<p>这篇文章我们不过多讨论如何生成Pyd文件，和使用这样的文件，该部分内容，我将在以后的关于在python中使用C/C++代码的文章中详细解释。上述内容是自己在Python应用中遇到过的问题，总有不足之处，望见谅并指正。</p>
<p>参考目录：</p>
<p><strong>PEP：441：</strong><a href="https://www.python.org/dev/peps/pep-0484/#stub-files" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0484/#stub-files</a></p>
<p><strong>PEP：441：</strong><a href="https://www.python.org/dev/peps/pep-0441/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0441/</a></p>
<p><strong>ERSI ArcGIS：</strong><a href="http://desktop.arcgis.com/zh-cn/arcmap/10.3/analyze/creating-tools/a-quick-tour-of-python-toolboxes.htm" target="_blank" rel="noopener">http://desktop.arcgis.com/zh-cn/arcmap/10.3/analyze/creating-tools/a-quick-tour-of-python-toolboxes.htm</a></p>
<p><strong>Magic_Nr:</strong> <a href="https://github.com/google/pytype/blob/master/pytype/pyc/" target="_blank" rel="noopener">https://github.com/google/pytype/blob/master/pytype/pyc/</a> magic.py</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/05/0802-ma-file-extension/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/01/0801-ma-zeropointone/"
                            aria-label=": Python 杂记之 Python不认识0.1"
                        >
                            Python 杂记之 Python不认识0.1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-01T08:11:08+08:00">
	
		    12月 01, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/">Python 相关 - 8. Python 杂记</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<h2 id="正文导语"><a href="#正文导语" class="headerlink" title="正文导语"></a><strong>正文导语</strong></h2><p>在计算机编程的过程中，常常会涉及到浮点数（小数）的算术运算。稍加留意就会发现，算术运算的结果时常是不正确的。如果程序中有条件语句if加逻辑判断来控制程序执行，由于判断结果也不符合预期，程序就会流向错误的节点。经典例子就是0.1的10次求和与1进行逻辑判断得出的结果为False，遇见相似的问题会把自己急出一身汗，却也弄不个所以然来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span></span><br><span class="line"><span class="number">0.9999999999999999</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么Pyhon不认识0-1"><a href="#为什么Pyhon不认识0-1" class="headerlink" title="为什么Pyhon不认识0.1"></a><strong>为什么Pyhon不认识0.1</strong></h2><p>通过上面的结果，可以大胆假设：<strong>其实Python不能正确理解0.1，因为若可以，结果就不会出问题</strong>。那么Python是不是不认识0.1呢？这是不是Python 这种编程语言的Bug（错误）？若不注意，在编程时会出现什么样的问题？出现这类问题的根本原因在哪？如何才能避免此类问题的出现呢？ 希望下面的内容能不能解决上述的疑问。</p>
<p>首先，咱们看看浮点数在计算机里如何表示。先举个栗子，例如，小数(0.125)10，在十进制中其值等于1/10 + 2/100 + 5/1000 的值，这都很容易理解。如果将其转化为二进制小数则为(0.001)2， 是0/2 + 0/4 + 1/8.。的值，有点难懂是吧，可以参考下面的运算过程。 注意，两者在数值上相等，区别为：前者为十进制小数，后者为二进制小数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a. 十进制小数 to 二进制小数的方法：<span class="string">"乘2取正, 顺序输出"</span>，即乘<span class="number">2</span>取整，余数继续</span><br><span class="line">乘<span class="number">2</span>取整重复至小数部分为零或达到指定精度，第一次为最高位，最后一次为最低位。</span><br><span class="line">例： 十进制小数(<span class="number">0.125</span>)<span class="number">10</span>的二进制小数算法如下: </span><br><span class="line">    <span class="number">0.125</span> * <span class="number">2</span> = <span class="number">0.25</span>   取整 <span class="number">0</span> 余 <span class="number">0.25</span></span><br><span class="line">    <span class="number">0.25</span> * <span class="number">2</span> = <span class="number">0.5</span>     取整 <span class="number">0</span> 余 <span class="number">0.5</span></span><br><span class="line">    <span class="number">0.5</span> * <span class="number">2</span> = <span class="number">1.0</span>      取整 <span class="number">1</span> 余 <span class="number">0</span></span><br><span class="line">则 (<span class="number">0.001</span>)<span class="number">2</span> 为小数(<span class="number">0.125</span>)<span class="number">10</span>的表达。</span><br><span class="line"></span><br><span class="line">b. 二进制小数 to 十进制小数，小数点后的权位表达方法为 <span class="number">2</span>^(<span class="number">-1</span>), <span class="number">2</span>^(<span class="number">-2</span>),</span><br><span class="line"> <span class="number">2</span>^(<span class="number">-3</span>), ... , <span class="number">2</span>^(-n)。则如果将二进制小数(<span class="number">0.001</span>)<span class="number">2</span>转换为十进制方法如下:</span><br><span class="line">     <span class="number">0</span>/<span class="number">2</span> + <span class="number">0</span>/<span class="number">4</span> + <span class="number">1</span>/<span class="number">8</span> = (<span class="number">0.125</span>)<span class="number">10</span></span><br><span class="line">感兴趣的朋友可以使用下面代码进行尝试。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.125</span></span><br><span class="line"><span class="number">0.125</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">10</span> + <span class="number">2</span>/<span class="number">100</span> + <span class="number">5</span>/<span class="number">1000</span></span><br><span class="line"><span class="number">0.125</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>/<span class="number">2</span> + <span class="number">0</span>/<span class="number">4</span> + <span class="number">1</span>/<span class="number">8.</span></span><br><span class="line"><span class="number">0.125</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>因为计算机内部的所有运算都是基于二进制的，在计算机内部，大部分的十进制的分数（大部的分数可以通过小数表达）却不能使用二进制完美地表达。这和十进分数1/3十分相似，可以取为0.3，或者精确一些取为0.33，或者再精确点取0.333，进而以此类推，在十进制下，可以无限接近，但是却不能绝对精确。相同的原因，十进制数(0.1)10不能通过一个二进制的小数准确地表达，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小数(0.1)10 转换为二进制小数，步骤如下：</span><br><span class="line">        0.1 * 2 &#x3D; 0.2 取整 0 余 0.2</span><br><span class="line">        0.2 * 2 &#x3D; 0.4 取整 0 余 0.4</span><br><span class="line">        0.4 * 2 &#x3D; 0.8 取整 0 余 0.8</span><br><span class="line">        0.8 * 2 &#x3D; 1.6 取整 1 余 0.6</span><br><span class="line">        0.6 * 2 &#x3D; 1.2 取整 1 余 0.2 </span><br><span class="line">        ... </span><br><span class="line">然后就开始无限循环了 -_- 。</span><br></pre></td></tr></table></figure>

<p>所以，在计算机内部，如果用一个二进制小数表达1/10 即 0.1 的时候，二进制的小数大概为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0.00011001100110011001100110011001100110011001100110011010</span>)<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>其值非常接近余1/10 但却不相等。一般情况下，我们会需要一个同一的标准，在IEEE 754 双精度浮点标准下，Python会用53位的精度来表达1/10。而此时如果我们将上面的二进制转换为小数应该会得到下面的值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0.1000000000000000055511151231257827021181583404541015625</span>)<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>其值非常接近于0.1却不等于0.1。这时候可能就有人会问，我在Python的交互界面下输入0.1时，交互界面打印出来的就是0.1啊，如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span></span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.1</span>)</span><br><span class="line">Decimal(<span class="string">'0.1000000000000000055511151231257827021181583404541015625'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>其实这时候，Python的交互命令行只打印了这个值的一小部分，真实值（注意这里的真实值也与实际值1/10不相等）的近似值。如果想查看完整的小数表达，可以使用decimal模块下的Decimal()函数，如上。</p>
<p>小结一下，<strong>Python确实不认识0.1。</strong>其实应该说，计算机不能准确地用二进制地方法表达0.1。如果能明白这些，就应该知道，<strong>这并不是Python这种语言的Bug</strong>，也不是自己代码的Bug，这是二进制浮点数的常见情况（不能称之为问题）。而且所有的编程语言会出现这种情况，所有支持浮点运算的计算机也都存在相似的情况，只是表现方式会有所差异。</p>
<p>若不注意这些，在编写代码的时候会出现什么样的潜在问题呢？因为计算机不能正确的表达1/10，显而易见的问题就是我们文章一开头的求和问题。遇见这样的问题时，有人会提出Python和一些编程语言提供round()函数，用于取舍不就会得到最接近的值？那该函数是不是也能够用在此处解决这样的问题呢？我们来做个实验，这个实验和文章开头有点不一样，我们也做0.1的求和，但是不做那么多次的加法，三次足亦，如下：</p>
<p>第一步，我们用最简单的方法求和，求三个0.1的和，然后和0.3进行比较，发现果然和预期（为真）的不一样。要注意：计算机不能正确表达0.1，同时0.3不能被正确表达。所以两者不相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> == <span class="number">0.3</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>第二步，我们用round()函数进行提前取舍，取舍精度都为1， 然后进行求和判断。发现结果也不符合预期，可以推测的是，先取舍再求和，最终结果也不和0.3相等。需要注意的是，这个过程不能验证，只要验证了结果就是对的，有点量子论里测不准的感觉，内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.1</span>, <span class="number">1</span>) + round(<span class="number">0.1</span>, <span class="number">1</span>) + round(<span class="number">0.1</span>, <span class="number">1</span>) == round(<span class="number">0.3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>第三步， 我们不提前取舍，先求和然后取舍，进而与0.3 进行比较，此时结果就符合预期了，而且调整取舍精度也能再次得到预期的结果，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>, <span class="number">1</span>) == round(<span class="number">0.3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>, <span class="number">10</span>) == round(<span class="number">0.3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中不仅仅是因为，计算机里二进制浮点数不能正确表达十进制分数的；还有一个原因是内置round()函数的取舍也有问题。例如，一个小数2.675舍入到小数点后两位，按照四舍五入的原则，预期的结果应该为2.68。但是实际不是，是2.67，原因就是计算机浮点数不能正确表达十进制分数（小数）。十进制小数2.675的在计算机内转换为浮点数后如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.67499999999999982236431605997495353221893310546875</span></span><br></pre></td></tr></table></figure>

<p>因为，这个数的数值更接近与2.67而不是2.68，所以使用round()函数时会向下取舍。</p>
<p>小结，因为计算机的二进制浮点数不能正确表达十进制分数，所以编程时遇见浮点数据运算就会得到诸如此类的奇异结果。但我们不能因为会遇见这样的怪异现象，就仇视或者惧怕浮点数和有意避免浮点数运算。此问题有种官方的叫法，叫做<strong>表达错误</strong>（representation error）。</p>
<h2 id="表达错误"><a href="#表达错误" class="headerlink" title="表达错误"></a><strong>表达错误</strong></h2><p>在这个章节中我们探索一下，十进制的分（小）数在计算机里是如何转换为二进制的浮点数的。也希望借助此章节的内容，各位能够更加深入地理解为什么编程语言不能按照预期表达十进制数值。</p>
<p>通过前面的章节我们已经确定，计算机确实不能正确地表达1/10，而如今绝大部分的计算机都使用IEEE-754的浮点数算法，而几乎所有的平台和版本的Python会将浮点数映射为IEEE-754的双精度浮点数。即，计算机会尽量将输入的十进制小数通过方程J/2^N转化为最接近的二进制小数，其中J为一个53位的整数，N为最佳指数。</p>
<p>举例来说，就拿1/10来说，如果该有理数需要在Python中需要转化为计算机的双精度浮点数，通过上面的方程来转化会写作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">10</span> ≈ J/<span class="number">2</span>^N <span class="comment">#近似等于</span></span><br></pre></td></tr></table></figure>

<p>转换等式，可得：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J ≈ <span class="number">2</span>^N / <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>因为双精度浮点数有52位来存储有效数字，而同时IEEE 754规定：在计算机内部保存有效数字时，默认这个小数（二进制）的第一位总是1，因此可以被舍去，只保存后面的内容。因此双精度浮点的有效数数字应该有53位。即在上式中J应该被定义为一个53位的整数。等式的右边应该无限接近于这个53位的整数即，应该满足大于等于2^52，小于2^53。通过计算可得当N等于56时满足条件，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">52</span></span><br><span class="line"><span class="number">4503599627370496L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">56</span> // <span class="number">10</span></span><br><span class="line"><span class="number">7205759403792793L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">53</span></span><br><span class="line"><span class="number">9007199254740992L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">52</span> &lt;=  <span class="number">2</span>**<span class="number">56</span> // <span class="number">10</span>  &lt; <span class="number">2</span>**<span class="number">53</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>接下来我们就要考虑这个等于2^56的整数是不是位最佳值，为此，需要得到该整数与10进行除法运算的商和余数，在这可以使用divmod()内置函数，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q, r = divmod(<span class="number">2</span>**<span class="number">56</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q, r</span><br><span class="line">(<span class="number">7205759403792793L</span>, <span class="number">6L</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>在上式中其除法运算的余数大于5，即更接近10，所以该整数的最佳近似值，应该向上取整，即在原来商的基础上加1。</p>
<p>因此，十进制的分数1/10，在IEEE 754 规定的双精度浮点的标准下，最佳近似值如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7205759403792794</span> / <span class="number">2</span> ** <span class="number">56</span></span><br><span class="line"><span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p>由于我们在计算的时，整数J向上取整了（式子为J/2^N)，也就意味着得到的浮点数应该比1/10要稍微大一点。而如果我们不向上取整，又会比1/10的实际值小一点点。反正不管怎么算，就是得能精确等于1/10，这就是为什么说Python从没见过1/10长什么样，即计算机其实不认识1/10。</p>
<p>我们再往下探索一下：由上可知，按照IEEE 754 标准，如果我们将最后一步中分子分母约分（因为分子为偶数，即公因数为2），则可以得到下面的内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3602879701896397</span> / <span class="number">2</span> ** <span class="number">55</span></span><br></pre></td></tr></table></figure>

<p>这时候，J为3602879701896397，N为55。如果我们想看到这个浮点数所有的有效数字，可以将小数整数化，也就是说让J乘以10^55，就可以得到一个55位的整数，如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3602879701896397</span> * <span class="number">10</span> ** <span class="number">55</span> // <span class="number">2</span> ** <span class="number">55</span></span><br><span class="line"><span class="number">1000000000000000055511151231257827021181583404541015625L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.1</span>)</span><br><span class="line">Decimal(<span class="string">'0.1000000000000000055511151231257827021181583404541015625'</span>)</span><br></pre></td></tr></table></figure>

<p>由上可得，得到的整数化的有效数字，和计算机内部存储的是相同的。也就证明了，整个推到过程是正确无误的。虽然计算机可以实现到53位的精度。但是因为编程语言中print足够聪明，所以如果直接输入0.1，打印出来的内容也就是0.1。因为大部分情况下，可能不需要这个高的精度，所以很多编程语言在做浮点数的算术运算的时候，一般取的是小数点后17位的精度，即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span></span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%.17f"</span> % <span class="number">0.1</span></span><br><span class="line"><span class="number">0.10000000000000001</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>因为运算的每一步都需要会涉及到精确度和有效数字丢失的问题，所以编程中，浮点数的计算常常会得到不满足预期的结果，但是浮点数又是很重要的一种数据类型，又不能够舍弃。总之，当遇见代码中出现浮点算术运算问题的时候，就应该考虑到是不是遇见了上面的问题，进而就要找到合适的计算方式，对计算结果进行精度上的取舍。而如果代码中设计到大量的浮点数计算，在Python中，就可以考虑使用专门的模块来处理这些计算。</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><strong>讨论</strong></h2><p>Python 的浮点数运算模块decimal，使用decimal中的Decimal函数可以允许浮点数以字符串的方式传入，这样就可以保有足够的（大于双精度浮点数的53位）有效数字，从而避免计算时精度的丢失。在本章的一开始遇见的0.1求和的问题就可以使用Decimal来解决，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Decimal(<span class="string">'0.0'</span>) <span class="comment"># 注意：传入字符串。若传入浮点数，就丢失了精度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    x += Decimal(<span class="string">'0.1'</span>) </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">Decimal(<span class="string">'1.0'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%.17f"</span> % x1<span class="number">.00000000000000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(x) == <span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>Decimal模块可以解决问题，在一些涉及到高精度计算或者一些金融方面的计算时，也能够保证不丢失精度，毕竟关乎钱的问题就不能允许有误差存在，但是这样的计算会却有牵扯到浮点数与字符串之间的转换问题，性能肯定会下降。程序设计是需要考虑到所有因素，假如17位的普通精度能够满足设计要求，而且计算允许一定的误差，同时又有性能上的要求，毕竟原生的浮点数计算速度会快很多，就可以使用math模块来解决类似的问题。</p>
<p>关于math模块我们在这里借助一个新的例子，这个例子更为典型也十分有趣，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1.23e+18</span>, <span class="number">1</span>, <span class="number">-1.23e+18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(nums)</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure>

<p>求和过程丢失了一个1，感觉十分神奇。其计算结果就不是近似了，根本就是完全错误。主要原因就是函数sum()做的就是一个加法运算，该函数不在意过程中精度的损失，只是简单的求和。为了避免上面的计算错误，就可以使用math模块下的fsum()函数来处理，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1.23e+18</span>, <span class="number">1</span>, <span class="number">-1.23e+18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.fsum(nums)</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>使用函数math.fsum()进行计算的时候，函数会回溯每一步计算的误差，在保持精度的同时得到计算的最优解，所以结果符合预期。总的来说，decimal模块可以被用于涉及到金融领域和科学计算的工程领域。但是一般问题中设计到浮点数计算的问题，math模块足够胜任。</p>
<p>在程序开发上遇到问题，如果追本溯源，就肯定能够找到问题的根本原因，也能够借助一篇篇文章了解问题出现的机理，进而明白一些现实因素的局限性，也能够扩展自己知识面，也希望大家能够通过这篇文章真正理解，为什么计算机不能正确认识1/10，即明白二进制下如何表达浮点数的方法。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p>IEEE754 的内容 ：<a href="https://de.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">https://de.wikipedia.org/wiki/IEEE_754</a></p>
<p>Python表达错误 ：<a href="https://docs.python.org/2/tutorial/floatingpoint.html" target="_blank" rel="noopener">https://docs.python.org/2/tutorial/floatingpoint.html</a></p>
<p>Python浮点计算 ：<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p02_accurate_decimal_calculations.html" target="_blank" rel="noopener">http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p02_accurate_decimal_calculations.html</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/01/0801-ma-zeropointone/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/23/0701-issue-twosum/"
                            aria-label=": Python 应用之 Two sum"
                        >
                            Python 应用之 Two sum
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-23T08:11:08+08:00">
	
		    11月 23, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-7-Python-%E5%BA%94%E7%94%A8/">Python 相关 - 7. Python 应用</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<p>最近一直考虑着下一篇关于Python的文章应该是什么样的内容，对比一些专业大咖的文章，目前应该写一个完整的且无错的程序，然后和大家一起一行行地分析代码相互学习，可是我实在不想如此亦步亦趋。在学习编程方面，我是一个实用主义者，认为“学以致用”才是学习的最终目的， 最近发现了一些有趣的东西，让我很感兴趣，也能检验我自己所学的东西。</p>
<p>本着“学以致用”为先，从今天开始我们通过研究算法的方式，进而明白自己之前学的内容如何更好地使用。之所以打算写这样方面的内容，也是因为最近的一次和猎头通话时，被问到类似的问题，可是自己竟然不会，丢脸啊。所以就下定决心研究算法，在此把自己所学所想跟大家分享。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><p>* 英文原文：</p>
<blockquote>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
</blockquote>
<p>* 我的理解：</p>
<blockquote>
<p>给定一个整数数组和一个目标值，求数组内两个元素和为目标值的指针。 需要保证每次输入都能得到正确的解，并且任何一个元素<strong>不能</strong>使用两次。</p>
</blockquote>
<p>* 例：</p>
<blockquote>
<p>如有列表 [2, 7, 11, 15] 若目标值 9， 因为 2 + 7 = 9， 所以得[0, 1]; 若目标值 18， 因为 7 + 11 = 18， 所以得[1, 2]。</p>
</blockquote>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a><strong>解决思路</strong></h2><ul>
<li><strong>第一步推导</strong></li>
</ul>
<p>使用最简单的思路暴力解决。 历遍列表中的每一个元素，然后检查是否相邻的两个元素的和是否和所求一致，如果相同则返回这两个元素的索引。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Approach1</span><span class="params">(listInput, iTarget)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Brute Force</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type listInput: List[int]</span></span><br><span class="line"><span class="string">        :type iTarget: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(listInput) &lt;= <span class="number">1</span>:            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> iDx <span class="keyword">in</span> range(len(listInput)):            </span><br><span class="line">            <span class="keyword">for</span> jDx <span class="keyword">in</span> range(<span class="number">1</span>, len(listInput)):                </span><br><span class="line">                <span class="keyword">if</span> listInput[jDx] == (iTarget - listInput[iDx]):</span><br><span class="line">                    <span class="keyword">return</span> [iDx, jDx]</span><br></pre></td></tr></table></figure>

<p>这样的方法虽然不能符合题目要求，因为列表中的每一个元素都被使用了两次。但是可以以此为基础，进一步探索找到解决问题的最优解。</p>
<ul>
<li><p><strong>第二步推导</strong></p>
<p>因为第一步推导中方法的时间复杂度为O(n^2)。 为了优化时间复杂度，就要尝试找到一个更加高性能的方法来检查一个元素与目标值的差是否存在于列表中。 而且当其差值存在，我们还要得到该元素的索引。 那么最好的保存两者映射的途径是什么？ 当然是一个哈希表，在Python中为字典。</p>
</li>
</ul>
<p>为了提高效率就要减少查找时间，准确地说把两者映射的查找次数从N降低到1。 而哈希表就是为此而生的。 理论上使用哈希表可以实现在恒定时间内完成查找。但是现实中可能会出现哈希函数不完善造成的冲突可能会导致查找次数重新从1退到n。 所以选择合适的哈希函数也是很重要的。 以此为思路优化第一步的推导，就得到下面的代码。 Python作为高级编程的语言，虽然解释器封装了哈希函数，也会存在碰撞冲突的风险，但一般很少出现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Approach2</span><span class="params">(listInput, iTarget)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Two-pass Hash Table</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type listInput: List[int]</span></span><br><span class="line"><span class="string">        :type iTarget: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(listInput) &lt;= <span class="number">1</span>:            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># dictBuffer = &#123;&#125;</span></span><br><span class="line">        <span class="comment"># for iDx in range(len(listInput)):</span></span><br><span class="line">        <span class="comment">#    dictBuffer[listInput[iDx]] = iDx</span></span><br><span class="line">        dictBuffer = dict(zip(listInput, range(len(listInput))))        </span><br><span class="line">        <span class="keyword">for</span> iDx <span class="keyword">in</span> range(len(listInput)):</span><br><span class="line">            iComplement = iTarget - listInput[iDx]            </span><br><span class="line">            <span class="keyword">if</span> dictBuffer.has_key(iComplement) <span class="keyword">and</span> dictBuffer.get(iComplement) != iDx:</span><br><span class="line">                <span class="keyword">return</span> [iDx, dictBuffer.get(iComplement)]</span><br></pre></td></tr></table></figure>

<p>上述的推导里面，使用了两个迭代，第一次迭代中（被注释的内容），循环将每个元素和其索引添加到字典内。然后在第二个迭代中，我们检查字典中是否存在其中一个元素差值为键的映射，如果存在就返回该元素以及差值对于的索引。 需要检验该差值不能为元素本身。</p>
<ul>
<li><strong>第三步推导</strong></li>
</ul>
<p>通过正确理解第二步推导，其实可以发现。 相同的目的也可以通过一次迭代完成。 在迭代的过程中，我们先判断当前元素是否存在于映射字典中，该映射字典保存了列表中一个元素与目标值的差以及该元素的索引。如果存在就立即返回。 若不存在，则将该元素与目标值的差作为键，其索引作为值，保存在这个映射字典中。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Approach3</span><span class="params">(listInput, iTarget)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        One-pass Hash Table</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type listInput: List[int]</span></span><br><span class="line"><span class="string">        :type iTarget: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(listInput) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dictBuffer = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> iDx <span class="keyword">in</span> range(len(listInput)):</span><br><span class="line">            <span class="keyword">if</span> listInput[iDx] <span class="keyword">in</span> dictBuffer:</span><br><span class="line">                <span class="keyword">return</span> [dictBuffer[listInput[iDx]], iDx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dictBuffer[iTarget - listInput[iDx]] = iDx</span><br></pre></td></tr></table></figure>

<p>可以看出第三步的推导能够满足题目的要求，即每个元素只能使用一次，而且解决方案的时间复杂度(O(n))和空间复杂度(O(n))都为最优。 关于算法的复杂度，即时间复杂度和空间复杂度的内容，我找机会总结后分享给大家。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>第三步推导完成之后，真的是醍醐灌顶。通过这三步推导，从最早的暴力解决，一步步地靠近正确的答案，发现这里面没有新的编程技术，也没有自创的数据类型。全都是之前文章介绍过的基本知识，可是通过改变这些基本内容的使用方法和方式，就能得到不一样的效果。也意识到，我们都有解决问题的能力和想到解决方案的智慧，只是很多时候面对问题时，都是以简单和快速为先，并没有考虑使用的方法是否最优。很多时候只要具有就是看下去的毅力和试下去的恒心，我们都能找到解决问题的最优解。</p>
<p>研究这个算法的过程，也认识到自己离软件大拿和行业翘楚还很远。也明白自己看待问题的眼光，解决问题的思路包括编程的思维都是有局限。这篇文章也作为我自己对待编程的新起点，希望与君相互讨论帮助，共同进步学习。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/23/0701-issue-twosum/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/21/030302-for/"
                            aria-label=": Python 循环语句for"
                        >
                            Python 循环语句for
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-21T08:11:08+08:00">
	
		    11月 21, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Python 相关 - 3. 基本语法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/21/030302-for/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/20/030301-if-elsif-else/"
                            aria-label=": Python 条件语句if-elif-else"
                        >
                            Python 条件语句if-elif-else
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-20T22:11:08+08:00">
	
		    11月 20, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Python 相关 - 3. 基本语法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/20/030301-if-elsif-else/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/20/030201-operator/"
                            aria-label=": Python 运算符"
                        >
                            Python 运算符
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-20T15:11:08+08:00">
	
		    11月 20, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Python 相关 - 3. 基本语法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<h2 id="Python运算符简介"><a href="#Python运算符简介" class="headerlink" title="Python运算符简介"></a>Python运算符简介</h2><p>程序语言运算符就是对数据操作的表示方法，即数据是如何处理的。理解运算符，在查看代码的时候就能理解代码中数据是如何加工处理的，掌握运算符就能过对数据按照自己所想操作加工处理。一般的教程或者学习资料会将操作符分为：算术运算符、连接运算符、关系运算符、赋值运算符和逻辑运算符。这也是普遍的共识。在本文中，我们稍作改变，我们分组分章节介绍，之所以这样，也是一些运算符好之间也有一定的关系。Python中有一种比较特殊的运算符，即身份运算，会单独介绍一下。位运算从本质上来讲也属于算术表达的一种，但是由于其比较特殊，常在硬件设计方面应用较多，日常的应用设计很少遇到，所以在文中也用单独的章节介绍。</p>
<h2 id="算术运算符与赋值运算符"><a href="#算术运算符与赋值运算符" class="headerlink" title="算术运算符与赋值运算符"></a>算术运算符与赋值运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术计算，在此是指常见的十进制计算，包括加法➕，减法➖，乘法✖️，除法➗，都是常见的数学计算，除了表现符号与数学课本上不一致，如，Python乘法（_），除法（/）。任何人理解这些符号的意义，在这里就不在赘述。在此我们仅介绍<strong>取模</strong>，<strong>取整</strong>， 和*幂运算(包括逆运算，即对数运算)_，Python中也有math或cmath模块，提供专门的函数来帮助你进行更复杂的算术运算，如有需要可以关注一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">c = a  // b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取整 c 的值为："</span>, c</span><br><span class="line"></span><br><span class="line">c = a % b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取模 c 的值为："</span>, c </span><br><span class="line"></span><br><span class="line">c = a ** b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"幂运算 c 的值为："</span>, c </span><br><span class="line"></span><br><span class="line">d = c ** (<span class="number">1.</span>/b)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"幂的逆运算 d 的值为："</span>, d</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取整 c 的值为： 3</span><br><span class="line">取模 c 的值为： 1</span><br><span class="line">幂运算 c 的值为： 49</span><br><span class="line">幂的逆运算 d 的值为： 7.0</span><br></pre></td></tr></table></figure>

<p>取整就是得到除法的结果的整数部分，取模就是得到除法的结果的余数（<strong>切记并非小数部分</strong>），幂运算可以处理平方，三次方等，幂运算符也可以处理幂运算的逆运算，即对数运算。上面代码1后面的那个点<strong>.</strong>就表示1要按照浮点数进行运算操作。</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算就是将算数运算结果赋值于变量，符号为<strong>=</strong>。 算术运算符➕与赋值的组合能过更简化代码，也就是常说的变量自加。即算术运算过程中等号左边的变量也作为算术运算的参与者，简单举个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a + b</span></span><br><span class="line">a += b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"加法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a - b</span></span><br><span class="line">a -= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"加法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a * b</span></span><br><span class="line">a *= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"乘法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a * b</span></span><br><span class="line">a *= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"乘法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a ** b</span></span><br><span class="line">a **= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"幂与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a // b</span></span><br><span class="line">a //= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取整与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a % b</span></span><br><span class="line">a %= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取模与赋值的值为：%s"</span> % a</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">加法与赋值的值为：10</span><br><span class="line">加法与赋值的值为：7</span><br><span class="line">乘法与赋值的值为：21</span><br><span class="line">乘法与赋值的值为：63</span><br><span class="line">幂与赋值的值为：250047</span><br><span class="line">取整与赋值的值为：83349</span><br><span class="line">取模与赋值的值为：0</span><br></pre></td></tr></table></figure>

<p>由于变量a参与了算术计算，所以变量a的值一直发生了变化，所以不要怀疑结果出了问题。</p>
<h2 id="比较运算符，成员运算符，身份运算符"><a href="#比较运算符，成员运算符，身份运算符" class="headerlink" title="比较运算符，成员运算符，身份运算符"></a>比较运算符，成员运算符，身份运算符</h2><p>这个章节的运算符，在编程中主要用于与条件语句进行配合，并返回True 与 Flase布尔值的运算符。</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符比较容易理解：等于==， 不等于!=或者&lt;&gt;, 大于&gt;与大于且等于&gt;=和小于&lt;与小于且等于&lt;= 。关于这些也就不再举例，需要注意的是比较的两个元素应该具有相同的数据类型，或者都是类的实例。</p>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>成员运算符是用于检查某一值是否在可迭代的对象里面，返回值True或False。</p>
<p>可迭代的对象Iterable并不等于迭代器Iterator。Python中这两种定义有部分相同，但是还是有一些细节的差异的。为了便于区分，这里给你一个简单的方法来区别彼此，能用for进行循环迭代的都成为可迭代对象，能被next()调用不断返回下一个值的对象为迭代器。有关两者更细节话的区别，我们在以后的文章中介绍。</p>
<p>可迭代的对象是一种集合数据类型，如list，tuple，dict，set与str等。成员运算符为”in”和”not in”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">21</span></span><br><span class="line">c = <span class="string">"a"</span></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line">lt = [<span class="number">11</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">tup = (<span class="number">11</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">ss = set([<span class="number">11</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">dic = &#123; <span class="string">"a"</span> : <span class="number">2</span>, <span class="string">"b"</span> : <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">in</span> lt:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 在给定的列表中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 不在给定的列表中"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">not</span> <span class="keyword">in</span> lt:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 不在给定的tuple 中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 在给定的tuple中"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">not</span> <span class="keyword">in</span> ss:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 不在给定的set 中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 在给定的set 中"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">in</span> dic:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 c 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 c 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d <span class="keyword">in</span> dic:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 d 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 d 不在给定的dict中"</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量 a 在给定的列表中</span><br><span class="line">变量 b 不在给定的tuple 中</span><br><span class="line">变量 b 不在给定的set 中</span><br><span class="line">变量 c 在给定的dict中</span><br><span class="line">变量 d 不在给定的dict中</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在Python 2.x中，成员运算符与dict结合使用的时候等效于has_key()函数，即用于检查是否字典dict变量存在某一键。但是Python 3.x不再具有该函数，所以只能用成员运算符。为了保证代码的兼容性和一致性，建议优先选用成员运算符来判断某一键存在与字典之中。在此我们也做个延伸，请看下方例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">e = &#123;<span class="string">"a"</span> : <span class="number">1</span>, <span class="string">"b"</span> : <span class="number">2</span>, <span class="string">"c"</span> : <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">akeys = e.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> e:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> akeys:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> e[<span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> e:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> akeys:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 不在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 不在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br></pre></td></tr></table></figure>

<p>有人可能会想，我在代码中某一处获取一个字典的所有键的列表，然后在以后需要判断的时候，直接使用这个键的列表来判断，这种想法是很危险的，也是不可取的。请参照上述例子。字典键的判断最好是按需实时进行，以避免误判。</p>
<h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于比较两个对象的储存单元。也就是判断两个引用的对象是否为同一个，即两个在储存意义上的一致。需要注意的是，Python程序中，<strong>值相同并不意味着”一致”，”一致”必然值相同</strong>。</p>
<ul>
<li><strong>is</strong> ，判断是否一致，是否引用自同一个对象 。 <strong>a is b</strong> 等效于 id(a) == id(b), id() 函数用于获取内存地址，地址一致则为同一个对象 。</li>
<li><strong>not is</strong>， 与<strong>not</strong> 结合，意指取上述内容反义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 没有相同的标识，不一致"</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 没有相同的标识，不一致"</span></span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = c </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">is</span> d :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 没有相同的标识，不一致"</span></span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = c[:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">is</span> d :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 没有相同的标识，不一致"</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a 和 b 有相同的标识，一致</span><br><span class="line">a 和 b 有相同的标识，一致</span><br><span class="line">c 和 d 有相同的标识，一致</span><br><span class="line">c 和 d 没有相同的标识，不一致</span><br></pre></td></tr></table></figure>

<p>从上述输出结果可以得知，整数（也包含浮点数）的变量，在值相同的情况下，赋值或者从新赋值，其引用的是同一块内存，列表在赋值的时候，上文中，从c赋值到d的时候也是引用的同一块内存。但是如果需要保证列表c和d在使用时相互之间不影响，就要对d进行重新赋值。这些都是需要在编写代码时候考虑的，从而避免不必要的错误。</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符常在条件语句和while循环语句中与上述的比较运算符，成员运算符与身份运算符结合使用。用于结合两个条件，或者否定某一条件。但是需要注意的是，其他语言中的逻辑运算符并不在Python语言中兼容，在程序代码转换时候需要注意。</p>
<table>
<thead>
<tr>
<th align="center">逻辑运算符（其他语言）</th>
<th align="center">逻辑运算符（Python）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">and</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">or</td>
</tr>
<tr>
<td align="center">！</td>
<td align="center">not</td>
</tr>
</tbody></table>
<p>代码实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">True</span></span><br><span class="line">b = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  a <span class="keyword">and</span> b :  <span class="comment"># 等效其他语言的 &amp;&amp;</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 有一个不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b : <span class="comment"># 等效其他语言的 ||</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true，或其中一个变量为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span>  a <span class="keyword">and</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 有一个不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true，或其中一个变量为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>( a <span class="keyword">and</span> b ): <span class="comment"># 等效其他语言的 ！</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 false，或其中一个变量为 false"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true"</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量 a 和 b 都为 true</span><br><span class="line">变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line">变量 a 和 b 有一个不为 true</span><br><span class="line">变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line">变量 a 和 b 都为 false，或其中一个变量为 false</span><br></pre></td></tr></table></figure>

<p>以上介绍的都是常用的运算符，在日常程序设计实现时常常用到，对比其他编程语言Python有一下独有的运算符，或一些运算符在Python中的表现形式会有一些不同，都需要在实现代码时注意。</p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符，会在硬件编程中用到，主要处理二进制的计算。在日常任务中并不常见，但是它也是学习进而掌握一种编程语言的必备知识。在我经历的任务中，比如需要得到RGB颜色的整数或者16进制数。RGB整数与RBG三色值之间的相互转换时，用到过位运算符。Python的位运算符与其他语言的位运算符一致，在本节我们介绍一下位运算符。</p>
<ul>
<li><strong>&amp;</strong>， 二进制的”<strong>与</strong>“操作。二进制相应位都位1，则结果为1，反之为0。</li>
<li><strong>|</strong>， 二进制的”<strong>或</strong>“操作。结合逻辑运算符来理解，二进制相应位有一个位1时，结果就为1，反之为0。</li>
<li><strong>^</strong>，二进制的”<strong>异或</strong>“操作。二进制相应位不同时，结果为1，反之为0。</li>
<li><strong>~</strong>， 二进制的”**取反”操作。二进制数按位取反，1变为0，0变为1。</li>
<li><strong>&lt;&lt;</strong>，二进制的”<strong>左移</strong>“操作。由符号”&lt;&lt;”右边的数字决定向左移动的位数，高位丢弃，低位补0。</li>
<li><strong>&gt;&gt;</strong>，二进制的”<strong>右移</strong>“操作。由符号”&gt;&gt;”右边的数字决定向左移动的位数，高位补0。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">50</span>           <span class="comment"># 50 = 0011 0010 </span></span><br><span class="line">b = <span class="number">14</span>           <span class="comment"># 14 = 0000 1110</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">c = a &amp; b;        <span class="comment"># 2 = 0000 0010</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a | b;        <span class="comment"># 62 = 0011 1110 </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a ^ b;        <span class="comment"># 60 = 0011 1100</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = ~a;           <span class="comment"># -51 = -0011 0011</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;       <span class="comment"># 200 = 1100 1000</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;       <span class="comment"># 12 = 0000 1100</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c 的值为dec： 2</span><br><span class="line">c 的值为bin：0b00000010</span><br><span class="line">c 的值为dec： 62</span><br><span class="line">c 的值为bin：0b00111110</span><br><span class="line">c 的值为dec： 60</span><br><span class="line">c 的值为bin：0b00111100</span><br><span class="line">c 的值为dec： -51</span><br><span class="line">c 的值为bin：-0b0110011</span><br><span class="line">c 的值为dec： 200</span><br><span class="line">c 的值为bin：0b11001000</span><br><span class="line">c 的值为dec： 12</span><br><span class="line">c 的值为bin：0b00001100</span><br></pre></td></tr></table></figure>

<p>可使用bin()内置函数来获取而数的二进制字符串，但是如果要更好的格式化字符串，即带有前补零和”0b”标示的二进制字符串时，则可使用{:#010b}”.format(value)来实现。</p>
<h2 id="运算符之间的优先级"><a href="#运算符之间的优先级" class="headerlink" title="运算符之间的优先级"></a>运算符之间的优先级</h2><p>尽然编程语言中的运算符种类如此之多，在相互之间结合使用的时候，哪个操作符会被先执行，这就是操作符之间的优先级问题。在此准备一表单，运算符优先级以数字形式表示，数值越小则表示优先级越高，即在运行时会被优先执行。</p>
<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">**</td>
<td align="left">指数运算，最高优先级</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">~ + -</td>
<td align="left">位的取反操作，一元加号与减号（标示数的正负）</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">* / % //</td>
<td align="left">乘，除，取模和取整</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">+ -</td>
<td align="left">加法，减法</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">&gt;&gt;,  &lt;&lt;</td>
<td align="left">位操作左移，位操作右移</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">&amp;</td>
<td align="left">位操作 与</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">^ ,  |</td>
<td align="left">位操作 异或 与 或</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">&lt;=, &lt;&gt;, &gt;=</td>
<td align="left">比较运算符</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left">&lt;&gt;, ==, !=</td>
<td align="left">等于，不等于运算符</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left">=, %=, /=, -=, +=, <em>=, *</em>=</td>
<td align="left">赋值运算符，自加，自减等</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left">is, is not</td>
<td align="left">身份运算符</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left">in, not in</td>
<td align="left">成员运算符</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left">not, and, or</td>
<td align="left">逻辑运算符</td>
</tr>
</tbody></table>
<p>传统数学计算时的优先级也在上述列表中得到体现，如，乘除法运算优先与加减法运算。括号可以提升优先级。操作符的优先级结合数学计算的优先级，又加上了编程语言的特有预算符的优先级。掌握运算符的优先级，没有什么技巧，只有在不断的实践中加深印象，从而实现熟练使用。</p>
<h2 id="运算符扩展—-函数注释-Function-Annotations"><a href="#运算符扩展—-函数注释-Function-Annotations" class="headerlink" title="运算符扩展— 函数注释 Function Annotations"></a>运算符扩展— 函数注释 Function Annotations</h2><p>Python 3.x 增加了一个新的特性Feature，叫做<strong>函数注释Function Annotations</strong>。其表现特征是函数定义是，在函数定义括号内使用”:”来注释参数，在右括号外添加”-&gt;”符号，来注释返回值。</p>
<p>我们来举个例子，传统意义上定义函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>添加注释的函数可以用如下形式表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span>, c: float)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>参数后的注释，即”:”后的内容可以是任何形式，返回值的注释需要注意返回值的数据类型必须为Python的数据类型。</p>
<p>函数的注视添加之后会以属性的形式保存在函数中。查看函数注释可以使用如下语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;'c': &lt;class 'float'&gt;, 'a': 'spam', 'b': (1, 10), 'return': &lt;class 'int'&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>函数注释只是一种附加的特征，其并不影响函数的传统方式的使用。参数的注释只是一种帮助信息，并没有现实意义上的约束力。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>编程语言的运算符，是学习编程语言的基础。熟练掌握才能进行其他方面知识的学习。目前网络中存在很多Python的教程，本人也无意重复别人做过的事情，只是将自己在学习这门编程语言的时的一些感悟，也对某一部分内容的个人见解与内容的延伸以文字的方式记录下来，这样在查看别的文章的时候，如果遇到一些基本知识的内容，就可以在不跳转别的教程网站的情况下，解决学习中遇到的问题，方便读者也方便自己。欢迎订阅我的个人微信公众号。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/20/030201-operator/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/19/030104-variable-dict-tips/"
                            aria-label=": Python 变量之字典与应用技巧"
                        >
                            Python 变量之字典与应用技巧
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-19T15:11:08+08:00">
	
		    11月 19, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Python 相关 - 3. 基本语法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<h2 id="Python-标准数据类型"><a href="#Python-标准数据类型" class="headerlink" title="Python 标准数据类型"></a><strong>Python 标准数据类型</strong></h2><p>大家好，最近更新比较慢，临近圣诞节和新年，公司的事情也就异常多。连续几天的会议，还要加紧修复bug，为新版本软件的发布做准备。好了言归正传，书接上回。Python 定义了一些标准数据类型，用于存储各种类型的数据。Python有五个标准的数据类型，分别是：</p>
<ul>
<li><ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
</li>
</ul>
<p>字典在Python中应该算是最后一个重要的基本变量，出现在代码中的频率也比较高。常被用作为一种可变的数据容器。今天就给大家介绍一下Python最后一个标准数据类型字典，即Dictionary的一些基础知识和在实际应用中的使用技巧。</p>
<h2 id="Dictionary-字典的特征"><a href="#Dictionary-字典的特征" class="headerlink" title="Dictionary 字典的特征"></a><strong>Dictionary 字典的特征</strong></h2><p>作为一种可变容器模型，那么字典Dict在声明之后就能够任意被修改，比如添加，删除，或者更改。既然名为字典也就意味着其查询索引方式类如真实意义上的字典。Python的自己由一组<strong>键（key）与值（value）</strong>组成。两者之间用冒号隔开（<strong>：</strong>）。组与组之间与逗号（，）隔开。最后用花括号(大括号) “<strong>{}</strong>“ 包裹所有的键值组，就得到一个字典实例，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">di = &#123;key_1 : value_1, key_2 : value_2, key_3: value_3&#125;</span><br></pre></td></tr></table></figure>

<p>字典中，每一组键值，其键需要有唯一性，但是其值则不需要。在Python中，字典键值的唯一性就限制了它的数据类型选择范围。结合前面文章所介绍的的标准数据类型，除<strong>列表</strong>以外：数值型，元组，字符串都能够作为字典类型的<strong>键</strong>，经过实践可以告诉大家，任何类的实例都可以作为字典的键。因为类一旦实例化，其类实例在内存中的地址具有唯一性，因此也可以作为字典的键，参考下面代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span>...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, a:<span class="string">"Object"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span>&gt;: <span class="string">'Object'</span>, <span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">[&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span>&gt;, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt; d.keys()[<span class="number">0</span>]</span><br><span class="line">&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span></span><br><span class="line">&gt;&gt;&gt;&gt; d.keys()[<span class="number">0</span>].isB = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()[<span class="number">0</span>]</span><br><span class="line">&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span>&gt;</span><br></pre></td></tr></table></figure>

<p>字典中，每组键值中的值，没有限定，可以是任意的数据类型。1. 键值是否可变，字典并不做约束，仅仅与数据类型本身有关。如下面代码的例子中，元组可以作为一对键值的值，因为元组本身不可变，所以该对键值的值不可变，但是不能因此认为字典的值不可改变。 2. 一对键值中，虽然字典也可以作为键值的值，而且在日常使用的时候也不会出现问题，但是在实际使用的时候，如果作为值的字典中存在bytes类的键值时，当尝试使用deepcopy复制字典实例的时候，可能会引发异常，当然类似的异常也会存在与复制相似结构的列表时诱发。各位可以留个印象，当以后遇见类似问题，或许可以帮助你确定异常诱发的原因。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mydict = &#123;<span class="string">"str"</span>: <span class="string">"String"</span>, <span class="string">"list"</span>: [<span class="string">"list1"</span>, <span class="string">"list2"</span>], <span class="string">"tuple"</span>: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) , <span class="string">"dictionary"</span> : &#123;<span class="string">"a"</span>: <span class="string">"1"</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mydict</span><br><span class="line">&#123;<span class="string">'list'</span>: [<span class="string">'list1'</span>, <span class="string">'list2'</span>], <span class="string">'dictionary'</span>: &#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, <span class="string">'str'</span>: <span class="string">'String'</span>, <span class="string">'tuple'</span>: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">注：上述代码中我们会发现一个问题，字典键值打印时，键值组的顺序和自己声明字典时的顺序</span><br><span class="line">不一致。这样的问题在字典历遍或者索引的时候也会遇到。标准的Python中会有一个名为</span><br><span class="line">collections的模块，在该模块下有一个名为OderedDict的类，该类为Dict的子类，但具</span><br><span class="line">有保持字典中键值顺序与声明时相一致的特性。</span><br></pre></td></tr></table></figure>

<p>总的来说，对于字典中键值对，键是由唯一且不可变的数据类型定义，准确地来说是可以哈希（hashable）的数据类型。值可以为任意数据类型。当同一键值被重复赋值，最后一次值将被采用。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/LNbO7CDlxmbTEl8FZc5icO1wlmSzmh1hmz96edbdYgnGu6yzrRGLqSfoLLonV16JRlvMHD1qCQHbo6QtKzdu3uA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<p>声明后的字典实例，修改添加和改变都很简单。其中为字典中添加一个元素和更改一个元素的书写方式是一样的。如下方代码：如果字典情况位置，键3值的修改和键4值的添加，方法一样。而列表再添加值的时候是需要使用类方法append()的。而如果使用数字作为键值，代码文件就由如<strong>d[3] = ‘d’</strong> 的内容， 这样的书写方法不利于代码的标准化，而且类似的需求完全可以由列表来实现。所以个人建议为了代码的标准化，使用字典时，还是应尽量避免数值类型作为键的值，避免代码出现歧义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">3</span>]</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">3</span>] = <span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">4</span>] = <span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>字典的删除操作，使用字典的类方法clear()可以删除字典中的所有元素，但是字典实例依旧存在。也可以使用关键字<strong>del</strong>来实现对字典单一元素和整个字典的清除。注意：使用关键字del删除整个字典，该字典的实例将从内存中清除，使用被清除的字典会引发异常。如下面代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'d'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Dictionary-字典的索引"><a href="#Dictionary-字典的索引" class="headerlink" title="Dictionary 字典的索引"></a><strong>Dictionary 字典的索引</strong></h2><p>Python中字典键值的索引总的来说有两种方法，一种使用方括号和键，类似列表的方法来索引和访问字典中的元素。第二种是使用get()类方法和键来索引和访问，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line">&gt;&gt; d.get(<span class="number">1</span>)</span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure>

<p>两种方法在效率上并没有差别，早前读过一篇文章讨论两种索引方式的效率。结果如下，结果显示使用方括号更直接高效。个人建议大家将图示的结果仅作为一个参考，因为也有Python开发人员有不同意见，认为实验方式有问题。</p>
<p>在实际应用的时候，我个人觉得两种方法的效率其实并没有太大差别，更值得关注的是get()方法能够更好地避免因为键不存在引起的索引异常。如下面代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">6</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="number">6</span>, <span class="string">"No Value"</span>)</span><br><span class="line"><span class="string">'No Value'</span></span><br></pre></td></tr></table></figure>

<p>由上述代码可以发现，在遇到字典中不存在的键的问题的时候，方括号+键的方式会引发异常，为了避免异常还要添加代码（通常为if语句）来检测该字典中是否存在所求键值组。而使用get()方法则能避免引发这个异常，当字典中不存在所求键值组的时，使用该方法返回空，或者你也可以给定第二个变量作为默认值，当该键值不存在则会返回默认值。在实际使用中该方法优选，可以很大程度地减少代码数量。</p>
<p>在这里我给大家介绍一个Python字典索引的<strong>应用技巧</strong>，具体方法如下方代码。假如一个字典有数字和字符串混合键，想要得到所有数字键的键值组。经典方法为，索引字典中的每一个键值组，检查键的数据类型，将符合条件的键值组的值加入一个列表里面，最终就可以得到所有符合要求的键值组的值的组合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'1'</span>: <span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="string">'2'</span>: <span class="string">"c"</span>, <span class="number">2</span> : <span class="string">"d"</span>, <span class="string">'3'</span>: <span class="string">"e"</span>, <span class="number">3</span>: <span class="string">"f"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'d'</span>, <span class="number">3</span>: <span class="string">'f'</span>, <span class="string">'1'</span>: <span class="string">'a'</span>, <span class="string">'3'</span>: <span class="string">'e'</span>, <span class="string">'2'</span>: <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intKeys = filter(<span class="keyword">lambda</span> e: isinstance(e, int), d.keys())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intKeys</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listValuesOfIntKeys = map(d.get, intKeys)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listValuesOfIntKeys</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'f'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>使用上述方法，可以避免索引整个字典，代码简洁有效。这里值得关注的是使用filter()+lambda关键字来筛选一个列表，和使用map()函数一次性地用不同参数调用同一函数（在这里为字典的get()方法）。这样的方法或许可以提供一种不同的解决问题的思路。</p>
<p>索引的特殊情况，历遍字典所有键值组。经典方法为<strong>for + in</strong> 的组合来进行迭代。请参考下方代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br></pre></td></tr></table></figure>

<p>该种方法也有效，但是不推荐使用。主要原因在于，底层代码要检验键值的唯一性，该方法会增加发生异常的频率。还有一个原因是for循环中的d[key] 会导致键再次被哈希，当字典较大时，这样的操作会消耗更多的时间。</p>
<p>我个人比较推荐使用下面的方法，这样的方法同时迭代键与值，而且更见安全。这在Python 2.7 中常被使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.iteritems():</span><br></pre></td></tr></table></figure>

<p>Python 3.0 会使用下面的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br></pre></td></tr></table></figure>

<h2 id="关于字典的内置函数和类方法"><a href="#关于字典的内置函数和类方法" class="headerlink" title="关于字典的内置函数和类方法"></a><strong>关于字典的内置函数和类方法</strong></h2><p>字典作为Python的标准数据类型，Python这种语言自然为其准备了一些内置方法，常见的主要如下：</p>
<blockquote>
<ol>
<li>len(dict) 函数：用于得到字典的长度，因为为键值组，所以键的数量和值的数量相当。</li>
<li>str(dict) 函数：用于输出字典可打印的字符串，其表示内容，可通过继承字典类型， 复写<strong>repr</strong>(self)类函数来格式化输出内容。</li>
<li>cmp(dict1, dict2）函数：用于比较字典的键值组是否完全一致，如果相同则返回真， 否则为假。</li>
</ol>
</blockquote>
<p>字典在Python中也算是一种类，既然是类就有类方法。上文中介绍了一些常见的类方法比如使用键得到值的get()方法，清除字典内所有元素的clear()方法和得到字典内所有键值组键的方法keys()。 除此之外常用的方法还有：</p>
<blockquote>
<ol>
<li><p>dict.copy() 类方法： 用于浅复制一个字典， 注。</p>
</li>
<li><p>dict.items() 类方法：返回值为该字典”（键，值）“样式的元组组成的列表 ，注。</p>
</li>
<li><p>dict.update(dict2) 类方法：使用dict2中的值，来更新dict中有相同键的键</p>
<p>值组的值。</p>
</li>
<li><p>dict.values() 类方法：返回字典中所有值组成的列表。</p>
</li>
<li><p>dict.has_key(key) 类方法：用于判断字典中是否含有该键，有为true，否则为假。</p>
</li>
<li><p>dict.pop(key, default) 类方法：该方法与get()相似，删除一组键值，如果该键不</p>
<p>存在则返回default值。 注： Python 2.x中有iteritems方法，在Python 3.0 中该方法被items()替代。 关于浅复制和深复制的内容，我将为在以后的文章中介绍给大家。</p>
</li>
</ol>
</blockquote>
<p>使用Python语言的内置方法和字典的类方法并结合一下编程技巧，我相信，各位读者能够正确使用字典来解决自己在项目中遇见的问题， 并在完成项目的同时会发现一些新的技巧，进而不断地提高自己的代码质量和代码效率。</p>
<p>Python基本数据类型中的字典和其使用技巧今天就介绍到这里，我也会尽我所能提高更新频率。努力归纳自己在工作中遇见的问题，并把自己找到的解决方法介绍给大家。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/19/030104-variable-dict-tips/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/18/030103-variable-tuple-tips/"
                            aria-label=": Python 变量之元组与应用技巧"
                        >
                            Python 变量之元组与应用技巧
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-18T15:11:08+08:00">
	
		    11月 18, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Python 相关 - 3. 基本语法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<h3 id="Python-标准数据类型"><a href="#Python-标准数据类型" class="headerlink" title="Python 标准数据类型"></a><strong>Python 标准数据类型</strong></h3><p>Python 定义了一些标准数据类型，用于存储各种类型的数据。Python有五个标准的数据类型，分别是：</p>
<ul>
<li><ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python 变量申明自由，使用灵活，每种数据类型都有存在的原因和使用的技巧。今天的文章我们就介绍一下<strong>元组</strong>的基本知识，介绍一下它的使用技巧，讨论一下它存在的原因。</p>
</li>
</ul>
<p><img src="/2018/11/18/030103-variable-tuple-tips/971594283516_.pic.jpg" alt="img"></p>
<h3 id="Python-数据类型之元组"><a href="#Python-数据类型之元组" class="headerlink" title="Python 数据类型之元组"></a><strong>Python 数据类型之元组</strong></h3><p>前一篇文章提到的五种标准变量类型中string, list, tuple 都属于序列(sequence)类型。Python内置共有6种序列类型变量，分别为：</p>
<h2 id="str-unicode-list-tuple-buffer-xrange-range"><a href="#str-unicode-list-tuple-buffer-xrange-range" class="headerlink" title="str, unicode, list, tuple, buffer, xrange(range)"></a><code>str, unicode, list, tuple, buffer, xrange(range)</code></h2><p>除一种可变序列类型，即List列表，其余的如tuple和range都属于不可变的序列类型。这里所谓的”不可变” （immutable）是说，对象创建之后，就不可以通过一些操作改变其内部状态，简言之就是对象本身不可改变。</p>
<p><img src="/2018/11/18/030103-variable-tuple-tips/981594283545_.pic.jpg" alt="img"></p>
<h3 id="Python-元组赋值与快速赋值"><a href="#Python-元组赋值与快速赋值" class="headerlink" title="Python 元组赋值与快速赋值"></a><strong>Python 元组赋值与快速赋值</strong></h3><p>Python 元组使用圆括号“（）”，作为与其他数据类型区别的标志， 元素之间用逗号“，”分隔。元组在创建时元素的数据类型不限，可以是各种数据类型的集合。与列表相似，元组中的每个元素都分配一个数字作为索引，第一个索引值为0， 第二个为1，以此类推。元组列表普通赋值定义方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> )</span><br><span class="line">tup3 = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</span><br></pre></td></tr></table></figure>

<p>初始化完成之后就可以使用元组。元组和上一篇关于列表的文章相似。如果元组初始化长度过长，就可以使用下列方法对元组赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">0</span>,) * <span class="number">5</span> <span class="comment"># 数字类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 = (<span class="string">""</span>,) * <span class="number">8</span> <span class="comment"># 字符串类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 </span><br><span class="line">(<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 = (<span class="literal">None</span>,) * <span class="number">9</span> <span class="comment"># 空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3</span><br><span class="line">(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4 = (<span class="literal">True</span>, )*<span class="number">7</span> <span class="comment"># 布尔类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4</span><br><span class="line">(<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>此方法快速高效，可以对指定长度的组元进行快速初始化，弊端在于不能在指定元素的类型，但可以按顺序混合元素的数据类型，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup5 = (<span class="literal">True</span>, <span class="string">""</span>)* <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup5</span><br><span class="line">(<span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>在这里要指出两点，一、此种快速赋值初始化元组理论上可行，但是不具有任何使用意义。理论上不存在，需要初始化一个元素相同的元组的情况。二、与列表不同，在初始化元组的候，如果元组中只有一个元素，那么需要在该元素后面添加逗号来消除歧义，如果没有，Python解释器会视为申明一个普通变量而非元组类型。</p>
<h3 id="Python-的列表索引，切片与排序"><a href="#Python-的列表索引，切片与排序" class="headerlink" title="Python 的列表索引，切片与排序"></a><strong>Python 的列表索引，切片与排序</strong></h3><p> Python 的元组索引方式和列表的索引方式相似：使用元组的变量名加方括号与索引值进行索引。Python的独特优势：在方括号中使用冒号“<strong>：</strong>”+“<strong>数字</strong>” 切片方式同样适用于元组。切片可以理解为：取元组中指定的<strong>连续</strong>元素，返回值同为元组。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">2</span>] <span class="comment"># 取第二个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">-1</span>] <span class="comment"># 取倒数第一个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">1</span>:] <span class="comment"># 取 从索引1至最后一个</span></span><br><span class="line">(<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[:<span class="number">2</span>] <span class="comment"># 取 从开始至索引2</span></span><br><span class="line">(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">-1</span>:] <span class="comment"># 取倒数第一个至倒数第一个</span></span><br><span class="line">(<span class="string">'Taobao'</span>,)</span><br><span class="line">注意：上述示例中，tup1[<span class="number">-1</span>]意为取最后一个，得到的结果为一个字符串类型，</span><br><span class="line">tup1[<span class="number">-1</span>:]也同为取最后一个，但因为指定了切片范围，则返回值为一个单一元素的元</span><br><span class="line">组。在编程时应注意这点，避免因数据类型问题写出很多不必要的代码。</span><br></pre></td></tr></table></figure>

<p>如同列表一样，元组在Python也是一个类。意味着元组有自己的类方法。可以通过类方法对元组进行操作。常用类方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    tup.count(obj) <span class="comment"># 某个元素在列表中出现的次数</span></span><br><span class="line"><span class="number">2</span>    tup.index(obj) <span class="comment"># 从列表中找出某个值第一个匹配项的索引位置</span></span><br></pre></td></tr></table></figure>

<p>感兴趣的可以对比一下<a href="http://mp.weixin.qq.com/s?__biz=MzU3MTI2ODk0MA==&mid=2247483757&idx=1&sn=32ceb9602e51d9964876cfc772b8034d&chksm=fce38b4ecb940258b0bc183b52ed4f43386e3a06334dda1f7e6396241957c8190be19782dbcd&scene=21#wechat_redirect" target="_blank" rel="noopener">上一篇关于列表</a>的文章，对比一下两者类方法相同与不同之处。简言之：<strong>元组不具有任何能改变自己的类方法</strong>。</p>
<p><img src="/2018/11/18/030103-variable-tuple-tips/991594283548_.pic.jpg" alt="img"></p>
<p>接下来我给大家介绍一下元组<strong>倒序排列</strong>(revers)和<strong>整理排序</strong>(sort)的应用技巧。整理排序时，默认情况下，数字元组排序规则为：由小到大；字符串元组排列规则：由“0”到“10”，然后由a到z；数字和字符串混合型元组排序规则为：先数字，后字符。请参考下方例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(tup) <span class="comment"># 使用Python内置方法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">注意，sorted()为Python编程语言的</span><br><span class="line">内置函数，元组不具有类似列表的类</span><br><span class="line">方法sort()用于排序。</span><br></pre></td></tr></table></figure>

<p>仔细观察上述示例，使用Python内置函数sorted()，返回值为一个列表，这与变量tup数据类型无关，仅与该函数的返回值类型有关。在元组倒序排列的问题，请参考下方例子，可以通过一种特殊的切片方法直接生成出一个倒序排列的新的元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup[::<span class="number">-1</span>] <span class="comment"># 采用切片法</span></span><br><span class="line">(<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reversed(tup)</span><br><span class="line">&lt;reversed object at <span class="number">0x00000000002AEED68</span>&gt;</span><br></pre></td></tr></table></figure>

<p>虽然python也有一个用于倒序排列的内置函数reversed() 也可以用于元组。此函数返回值为一个元组型的迭(die)代器实例，而非一个新的元组，所以说用类似“<strong>[::-1]</strong>”切片方式才是元组倒序排列的最佳选择。</p>
<p>Python编程语言一些内置函数，比如：元组间比较cmp()，获取长度len()，最大值max()和最小值min()，转变为列表list(seq)等，这些函数不仅适用于列表，也同样适用于元组，毕竟两者都属于序列类型。如上篇文章所介绍的，用于检测是否为<strong>非空</strong>的函数all()，和是否有任一个元素为<strong>空</strong>的函数any也能用于元组。</p>
<h3 id="列表与元组"><a href="#列表与元组" class="headerlink" title="列表与元组"></a><strong>列表与元组</strong></h3><p>如果大家开始学习Python，学到这里的时候，脑子里都应该有这样一个问题，Python中有列表这种数据类型，为什么还需要一个元组。接下来我们来探讨一下其存在的原因。</p>
<p>列表和元组两者是相似的数据类型，都是作为一个容器，用于存储数据。本质上都属于序列类型，但列表可变，元组不可变。除了关注”变”以外，理论上我们还需要注意他们在语法上的应用区别，元组应当作为异构的数据集合（元素数据类型不同），类似于C语言里面的struct 结构体；列表应当作同构的数据集合（元素数据类型相同），类似与C语言中的array数组。两者在Python中的使用原则应为，<strong>元组关注结构，列表关注排列</strong>。但在实际应用中，因为Python的列表并不限制数据类型，所以这一原则并没有被严格遵守。</p>
<p>元组使用场景通常为：同时为多个变量名赋值；一次性为函数传递所有参数和调用函数时一次性返回不同的类型的数据，如下：</p>
<ul>
<li>场景一，为多个变量名同时赋值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># case 1： 使用元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># case 2： 使用列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>   <span class="comment"># case 3： 此种方法也视为 元组赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = d         <span class="comment"># case 4： 此种方法也视为 元组赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = d         <span class="comment"># case 5： 此种方法也视为 元组赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>虽然上述场景中，case1与case2, case4与case5能达到相同的目的但是本质上来讲case2和case5都是由Python解释权将列表转换为元组，然后再给a, b, c三个变量赋值的。case3比较特殊，虽然没有使用圆括号，但是Python的解释权会自动讲”1， 2， 3“ 转换为元组，然后进行赋值。</p>
<ul>
<li>场景二，一次性为函数传递所有参数：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(a=<span class="string">""</span>, b=None, c=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"a : "</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> a,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">" b : "</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> b,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">" c : "</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> c</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)     <span class="comment"># 使用元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(d)           <span class="comment"># 错误方式</span></span><br><span class="line">a :  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  b :  <span class="literal">None</span>  c :  <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(*d)          <span class="comment"># 正确方式a :  1  b :  2  c :  3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]     <span class="comment"># 使用列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(d)           <span class="comment"># 错误方式</span></span><br><span class="line">a :  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  b :  <span class="literal">None</span>  c :  <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(*d)          <span class="comment"># 正确方式</span></span><br><span class="line">a :  <span class="number">1</span>  b :  <span class="number">2</span>  c :  <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>同样的虽然上述场景中，使用列表和元组通过正确地方式都能够一次性地传递多个参数给函数fun1()。 但是与场景一相同，都是由Python解释权将列表转换为元组，然后再给a, b, c三个参数赋值的。</p>
<p> 场景三，调用函数时一次性返回不同的类型的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"HalloWorld"</span>, <span class="number">1</span>, <span class="literal">False</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun2()</span><br><span class="line">(<span class="string">'HalloWorld'</span>, <span class="number">1</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>上述场景中的问题，<strong>只能</strong>通过元组来实现（圆括号有与无，都为元组）。虽然也可以定义一个列表，将所有返回值打包然后返回一个列表，但是会产生许多不必要的代码，还需要索引使用返回值，过于繁琐。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]: <span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"123"</span>: <span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>在做上述相同工作的时候，列表和远足可以得到相似的结果，但是效率上呢？我们做些测试，如下：</p>
<p>测试一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python -mtimeit <span class="string">"['fee', 'fie', 'fo', 'fum']"</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">0.432</span> usec per loop</span><br><span class="line">$ python -mtimeit <span class="string">"('fee', 'fie', 'fo', 'fum')"</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">0.0563</span> usec per loop</span><br></pre></td></tr></table></figure>

<p>测试二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = tuple(range(<span class="number">1000</span>))</span><br><span class="line">b = list(range(<span class="number">1000</span>))</span><br><span class="line">a.__sizeof__() <span class="comment"># 8024</span></span><br><span class="line">b.__sizeof__() <span class="comment"># 9088</span></span><br></pre></td></tr></table></figure>

<p>第一个测试中，我们分别创建元素相同的列表和元组。然后测试Python解释器创建它们所需时间，进而得出最优值。我们可以发现元组的创建时间是列表创建时间的八分之一。第二个测试中，我们尝试初始化相同长度的元组和列表，然后比较两个所需内存大小，结果现实元组相比列表所需内存相对较少。总而言之：元组的性能优于列表。在需要关注性能与内存使用率的时候，元组还是最优选择。</p>
<p>但如果作为仅作为序列型的数据，忽略两者性能上的差异，列表可以完全替代元组解决程序中遇到的问题。这样的话，是不是在Python中，元组就没有专属的应用场景了呢？是不是就不存在非元组不可的情况呢？<strong>当然不是</strong>。</p>
<p>列表作为可变序列，是不可以成为字典（dictionary，Python的一种数据类型）的键值（即key）的，而元组为不可变序列则可以作为键值。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a    = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">b    = [<span class="number">1</span>,<span class="number">2</span>] </span><br><span class="line">c = &#123;a: <span class="number">1</span>&#125;     <span class="comment"># 合法</span></span><br><span class="line">c = &#123;b: <span class="number">1</span>&#125;     <span class="comment"># 非法</span></span><br></pre></td></tr></table></figure>

<p>该种情况的使用场景为：如果需要将<strong>经纬度</strong>当多一个字典的键值时；如果需要将<strong>行列值</strong>作为一个字典的键值是；如果需要讲<strong>屏幕位置</strong>作为一个字典的键值等。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/18/030103-variable-tuple-tips/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/11/15/030102-variable-list-tips/"
                            aria-label=": Python 变量之列表与应用技巧"
                        >
                            Python 变量之列表与应用技巧
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-11-15T15:11:08+08:00">
	
		    11月 15, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">Python 相关 - 3. 基本语法</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p>
<h3 id="Python-标准数据类型"><a href="#Python-标准数据类型" class="headerlink" title="Python 标准数据类型"></a><strong>Python 标准数据类型</strong></h3><p>Python 定义了一些标准数据类型，用于存储各种类型的数据。Python有五个标准的数据类型，分别是：</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python 中的变量赋值不需要类型声明，也就是说声明变量不需要使用关键字。Python 中变量赋值之后该变量就被创建。可以简单对单一变量赋值，亦可对同一变量重新赋值（不同数据类型也可以），也可以同时为多个变量赋值，如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span> <span class="comment"># 赋值整型变量</span></span><br><span class="line">miles = <span class="number">1000.0</span> <span class="comment"># 浮点型</span></span><br><span class="line">name = <span class="string">"John"</span> <span class="comment"># 字符串</span></span><br><span class="line">ame = <span class="number">100</span> <span class="comment"># ame 被定义为新的数据类型</span></span><br><span class="line">ame1 = ame2 = ame3 = <span class="number">100</span> <span class="comment">#此三个变量被同时定义和赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="Python-数据类型之列表"><a href="#Python-数据类型之列表" class="headerlink" title="Python 数据类型之列表"></a><strong>Python 数据类型之列表</strong></h3><p>Python的变量灵活多变，不同的变量类型也有不同的使用技巧。上述的五种标准变量类型中string, list, tuple 都属于序列(sequence)类型。Python内置共有6种序列类型变量，分别为：</p>
<h2 id="str-unicode-list-tuple-buffer-xrange-range"><a href="#str-unicode-list-tuple-buffer-xrange-range" class="headerlink" title="str, unicode, list, tuple, buffer, xrange(range)"></a><code>str, unicode, list, tuple, buffer, xrange(range)</code></h2><p>其中只有一种可变序列类型，即List列表，其余的如tuple和range（关于xrange和range的区别，我会在以后总结介绍，或者可以在百度知道搜索#<strong>python for in原理</strong>#参考我的回答）都属于不可变的序列类型。这里所谓的”变” （mutable）是说，在对象创建之后，可以通过一些操作改变其内部状态，简言之就是改变对象本身。因为最近的工作遇到了很多关于列表的问题，今天我就借助这篇文章给大家介绍Python基本变量类型中的List，同时也给大家介绍一下List和Python内置函数相互配合的使用技巧。</p>
<h3 id="Python-列表赋值与快速赋值"><a href="#Python-列表赋值与快速赋值" class="headerlink" title="Python 列表赋值与快速赋值"></a><strong>Python 列表赋值与快速赋值</strong></h3><p>Python 列表使用方括号“[ ]”， 元素之间用逗号“，”分隔。列表元素的数据类型不限，可以是各种数据类型的集合，这点要比其他编程语言方便。列表元素个数不限，理论上只要内存足够大，元素个数就可以无限大。列表中的每个元素都分配一个数字作为索引，第一个索引值为0， 第二个为1，以此类推。List 列表普通赋值定义方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">list3 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br></pre></td></tr></table></figure>

<p>然后就可以使用列表，但是在一些实际应用中需要初始化给定长度的列表，并对列表中每一个元素进行赋<strong>初值</strong>。如果列表长度在10以内，普通赋值依旧适用。如果列表长度过长，有可能需要写个循环进行赋值。<strong>技巧</strong>：可以使用下列方法对列表进行赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">0</span>] * <span class="number">5</span> <span class="comment"># 数字类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 = [<span class="string">""</span>] * <span class="number">8</span> <span class="comment"># 字符串类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2</span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3 = [<span class="literal">None</span>] * <span class="number">9</span> <span class="comment"># 空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3</span><br><span class="line">[<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list4 = [<span class="literal">True</span>] *<span class="number">7</span> <span class="comment"># 布尔类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list4</span><br><span class="line">[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure>

<p> 该方法快速高效，可以对指定长度的列表进行快速初始化，弊端在于不能在限定元素的类型，但可以按序混合元素的数据类型，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list5 = [<span class="literal">True</span>, <span class="string">""</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list5</span><br><span class="line">[<span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Python-的列表索引，切片，改变与排序"><a href="#Python-的列表索引，切片，改变与排序" class="headerlink" title="Python 的列表索引，切片，改变与排序"></a><strong>Python 的列表索引，切片，改变与排序</strong></h3><p>Python 的列表索引方式和其他编程语言相似，即使用列表变量名，方括号与索引值进行索引。但Python与其他语言相比又有独特优势。即在方括号中使用冒号“<strong>：</strong>”+“<strong>数字</strong>” 对列表进行切片。切片可以理解为：取列表中指定的<strong>连续</strong>元素。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1 = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[<span class="number">2</span>] <span class="comment"># 取第二个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[<span class="number">-1</span>] <span class="comment"># 取倒数第一个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[<span class="number">1</span>:] <span class="comment"># 取 从索引1至最后一个</span></span><br><span class="line">[<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[:<span class="number">2</span>] <span class="comment"># 取 从开始至索引2</span></span><br><span class="line">[<span class="string">'Google'</span>, <span class="string">'Runoob'</span>]</span><br></pre></td></tr></table></figure>

<p>Python 的列表是一个类的实例，也就意味着列表有自己的类方法。可以通过类方法对列表进行改变或者其他操作。常用类方法如下：</p>
<ol>
<li>list.append(obj) # 在列表末尾添加新的对象</li>
<li>list.count(obj) # 某个元素在列表中出现的次数</li>
<li>list.extend(seq) # 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li>list.index(obj) # 从列表中找出某个值第一个匹配项的索引位置</li>
<li>list.insert(index, obj) # 将对象插入列表</li>
<li>list.pop(obj=list[-1]) # 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li>
<li>list.remove(obj) # 移除列表中某个值的第一个匹配项</li>
<li>list.reverse() # 反向列表中元素</li>
<li>list.sort([func]) # 对原列表进行排序</li>
</ol>
<p>在这里我给大家介绍一下列表操作中，<strong>倒序排列</strong>(revers)和<strong>整理排序</strong>(sort)的应用技巧。整理排序时，默认情况下，数字列表排序规则为：由小到大；字符串列表排列规则：由“0”到“10”，然后由a到z；数字和字符串混合型列表排序规则为：先数字，后字符。请参考下方例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lt) <span class="comment"># 使用内置方法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt.sort() <span class="comment"># 使用类方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    </span><br><span class="line">注意，sort() 为数据类型列表的类方法，</span><br><span class="line">sorted()为Python编程语言的内置函数。</span><br></pre></td></tr></table></figure>

<p>由上述例子可知，使用Python内置函数，返回值为一个列表，使用列表的类方法则返回值为空。意思就是说：在整理排序时，内置函数不改变原始列表，而使用类方法则原始列表将发生变化。在处理某些问题的时候，我们需要保持原始列表不变，这时候就应该考虑，哪一种方法更合适。这样的情况在倒序排列的时候也会发生，使用reverse()类方法时，虽然得到了倒序排列的列表，但是列表本身发生了变化，为了避免类似情况发生，备份一下原始列表是一种方法，但是会比较复杂。在这里我给大家介绍一个实用技巧。我们可以通过一种特殊的列表切片方法直接生成出一个倒序排列的新的列表，请参考下方例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt[::<span class="number">-1</span>] <span class="comment"># 采用切片法</span></span><br><span class="line">[<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt.reverse() <span class="comment"># 采用类方法</span></span><br><span class="line">&gt;&gt; lt</span><br><span class="line">[<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>

<p>虽然python也有一个用于倒序排列的内置函数reversed(). 但是与sorted()函数不同，此函数返回值为一个列表迭(die)代器实例（iterator，以后的文章会详细介绍迭代器）而非一个新的列表，所以说用类似“<strong>[::-1]</strong>”的列表切片更为合适。</p>
<p>Python编程语言还有一些其它的内置函数用于处理列表。比如：不同列表间比较cmp(list1, list2)，获取列表长度len(list)，最大值max(list)最小值min(list)，将元素变为列表list(seq)等。</p>
<blockquote>
<p>Tipp 1: 虽然list不是python的保留字符 可以用list作为变量名，而且不会产生错误。 但是还是不建议使用其作为变量名。</p>
<p>Tipp 2: 其实python还有其他的不经常用到 的内置函数: 用all(list)来检查列表中是否所有元素都 为非空。 用any(list)来检查列表中是否有任何一个 为空。</p>
</blockquote>
<h3 id="Python-列表数据类型转换和应用技巧"><a href="#Python-列表数据类型转换和应用技巧" class="headerlink" title="Python 列表数据类型转换和应用技巧"></a><strong>Python 列表数据类型转换和应用技巧</strong></h3><p>列表数据转换问题，一般分为两种情况。列表中元素的数据类型转换问题和整个列表数据类型转换问题。</p>
<p>列表元素数据类型转换，常见问题为数值类型和字符串类型间转换。例如将列表中的数字化字符串元素转换为数值类型元素，或反之； 或者将字符串列表的所有元素拼接，或反之。请参考下面例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ll = [<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>, <span class="number">5.6</span>] <span class="comment"># 将数值型转换为字符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ll</span><br><span class="line">[<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>, <span class="number">5.6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(str, ll)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2.3'</span>, <span class="string">'3.4'</span>, <span class="string">'4.5'</span>, <span class="string">'5.6'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = [<span class="string">'1'</span>, <span class="string">'2.3'</span>, <span class="string">'3.4'</span>, <span class="string">'4.5'</span>, <span class="string">'5.6'</span>]  <span class="comment"># 将字符型转换为数值型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(float, ss)</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>, <span class="number">5.6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tt = [<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span>] <span class="comment"># 元素拼合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tt</span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">""</span>.join(tt)</span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">"hello"</span>  <span class="comment"># 字符串拆分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(st)</span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure>

<p> 列表整体式地数据类型转换，常见问题：将列表整体转换为一个字符串和将一个字符串中的<strong>列表部分</strong>转换为一个列表。第一种情况请参考下方例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(ss)</span><br><span class="line"><span class="string">"['a', 1, 'c', 3, 'b', 2]"</span></span><br></pre></td></tr></table></figure>

<p>可以看出只需要使用python的内置方法str()就实现。可是如果是第二种情况呢？如果要将字符串化的列表转换为一个列表，<strong>千万不要</strong>使用内置函数list()。因为不会得到预期的结果，这里要使用内置函数eval()。参考下方代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">"['a', 1, 'c', 3, 'b', 2]"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(st) <span class="comment"># 若使用list函数</span></span><br><span class="line">[<span class="string">'['</span>, <span class="string">"'"</span>, <span class="string">'a'</span>, <span class="string">"'"</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'1'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">"'"</span>, <span class="string">'c'</span>, <span class="string">"'"</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'3'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">"'"</span>, <span class="string">'b'</span>, <span class="string">"'"</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'2'</span>, <span class="string">']'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(st) <span class="comment"># 若使用eval函数</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>Python基本数据类型中的List列表和列表的使用技巧今天就介绍到这里。想比大家都有这样的印象：如果能合理并巧妙地使用python内置函数来处理列表，将能够大大减少代码数量和提高代码质量。如果大家有别的想法或者其他使用技巧。欢迎订阅我的个人微信公共号，留言分享。</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/11/15/030102-variable-list-tips/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/"
                aria-label="上一页"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>上一页</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/page/3/"
                aria-label="下一页"
            >
              <span>下一页</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 2 页 共 3 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 Jim Wang. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avater.png" alt="作者的图片"/>
        
            <h4 id="about-card-name">Jim Wang</h4>
        
            <div id="about-card-bio"> <hr style='margin: 5px auto; border-top: 1px solid rgba(255,255,255,0.14); width: 20%;'> <span>全栈探索之路<span> <hr style='margin: 8px auto; border-top: 1px solid rgba(255,255,255,0.14); width: 60%;'> 记录个人对技术的理解和开发过程中遇到的问题，欢迎了解更多。 </div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>软件工程师</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                河南，中国
            </div>
        
    </div>
</div>

        




    
        
    



    
        
    

<div id="wechat">
    <div id="wechat-card">
        <div id="wechat-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="wechat-qrcode-picture" src="/assets/images/wechat-qrcode.jpg" alt="global.wechat_public_qr_code_image"/>
        
        
            <div id="wechat-qrcode-desc"><p>请扫描上方的二维码订阅我的个人微信公众号</p> <hr style='margin: 8px auto; border-top: 2px solid rgba(1, 1, 1, 0.14); width: 60%;'> <p>原创不易，多多点赞分享支持。</p></div>
        
        
            <img id="wechat-searchbar-picture" src="/assets/images/wechat-search-white.png" alt="global.wechat_public_search_bar_image"/>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/background-cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-gm6c7itfvqwsezy1fdbvshhzjvi8xskdhlwee7qrhwsbsbmeopxkn4jz7zz9.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
