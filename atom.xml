<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jim Wang</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-25T00:11:08.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jim Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Inno Setup 如何以管理员的身份运行</title>
    <link href="http://yoursite.com/2019/06/25/inno-01-run-as-admin/"/>
    <id>http://yoursite.com/2019/06/25/inno-01-run-as-admin/</id>
    <published>2019-06-25T00:11:08.000Z</published>
    <updated>2019-06-25T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="Inno-Setup-如何以管理员的身份相关"><a href="#Inno-Setup-如何以管理员的身份相关" class="headerlink" title="Inno Setup 如何以管理员的身份相关"></a>Inno Setup 如何以管理员的身份相关</h2><h3 id="1-如何以管理员身份运行一个Batch脚本文件"><a href="#1-如何以管理员身份运行一个Batch脚本文件" class="headerlink" title="1. 如何以管理员身份运行一个Batch脚本文件"></a>1. 如何以管理员身份运行一个Batch脚本文件</h3><p>If you are using <code>[Run]</code> section then make sure you use <code>runascurrentuser</code> flag (If this flag is specified, the spawned process will inherit Setup/Uninstall’s user credentials (typically, full administrative privileges))</p><p>Else there are three ways how to run applications programatically (recommended way):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Exec(const Filename, Params, WorkingDir: String; const ShowCmd: Integer; const Wait: TExecWait; var ResultCode: Integer): Boolean;</span><br><span class="line"></span><br><span class="line">function ShellExec(const Verb, Filename, Params, WorkingDir: String; const ShowCmd: Integer; const Wait: TExecWait; var ErrorCode: Integer): Boolean;</span><br><span class="line"></span><br><span class="line">function ShellExecAsOriginalUser(const Verb, Filename, Params, WorkingDir: String; const ShowCmd: Integer; const Wait: TExecWait; var ErrorCode: Integer): Boolean;</span><br></pre></td></tr></table></figure><p>You should use <code>Exec()</code> or <code>ShellExec()</code> because they open the specified file or performs another action specified by Verb, using the same credentials as Setup/Uninstall.</p><p>But none of mentioned ways will work if your installer is not running in elevated mode. So make sure the UAC window will appear before installer starts:</p><p>In section <code>[Setup]</code> use directive <code>PrivilegesRequired</code></p><p>Valid values:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">none&#96;, &#96;poweruser&#96;, &#96;admin&#96;, or &#96;lowest</span><br></pre></td></tr></table></figure><p>Use admin to ensure appropriate credentials.</p><h3 id="2-各个合法值在不同版本中的表现"><a href="#2-各个合法值在不同版本中的表现" class="headerlink" title="2. 各个合法值在不同版本中的表现"></a>2. 各个合法值在不同版本中的表现</h3><h4 id="合法值为："><a href="#合法值为：" class="headerlink" title="合法值为："></a>合法值为：</h4><ul><li>none, poweruser, admin, or lowest</li></ul><h4 id="默认值为：Default-value"><a href="#默认值为：Default-value" class="headerlink" title="默认值为：Default value:"></a>默认值为：Default value:</h4><ul><li>admin</li></ul><h4 id="描述Description"><a href="#描述Description" class="headerlink" title="描述Description:"></a>描述Description:</h4><p>The effect of this directive depends on which version of Windows the user is running:</p><p>此参数的效果取决于用户运行的Windows版本：</p><p><strong>On Windows Vista and later:</strong></p><p>This directive affects whether elevated rights are requested (via a User Account Control dialog) when the installation is started.</p><p>该指令影响安装开始时是否要求提升权限（通过“用户帐户控制”对话框）。</p><p>When set to admin (the default) or poweruser, Setup will always run with administrative privileges. If Setup was started by an unprivileged user, Windows will ask for the password to an account that has administrative privileges, and Setup will then run under that account.</p><p>当设置为admin（默认）或超级用户时，安装程序将始终以管理特权运行。 如果安装程序是由非特权用户启动的，则Windows将要求输入具有管理特权的帐户的密码，然后安装程序将在该帐户下运行。</p><p>When set to none, Setup will only run with administrative privileges if it was started by a member of the Administrators group. Do not use this setting unless you are sure your installation will run successfully on unprivileged accounts.</p><p>如果设置为none，则安装程序仅由Administrators组的成员启动时才具有管理特权。 除非您确定安装将在非特权帐户上成功运行，否则不要使用此设置。</p><p>When set to lowest, Setup will not request to be run administrative privileges even if it was started by a member of the Administrators group. Additionally, the uninstall info root key will always be HKEY_CURRENT_USER, and the “common” forms of the Shell Folder constants are mapped to the “user” forms, even if administrative privileges are available. Do not use this setting unless you are sure your installation will run successfully on unprivileged accounts.</p><p>设置为最低时，即使安装程序是由Administrators组的成员启动的，它也不会请求运行管理权限。 此外，卸载信息的根密钥将始终为HKEY_CURRENT_USER，并且即使具有管理特权，Shell文件夹常量的“公共”形式也将映射到“用户”形式。 除非您确定安装将在非特权帐户上成功运行，否则不要使用此设置。</p><p><strong>On Windows NT/2000/XP/2003</strong></p><p>This directive specifies the minimum user privileges required to run the installation.</p><p>该指令指定运行安装所需的最低用户特权。</p><p>When set to admin (the default), Setup will only run if the user is a member of the Administrators group. Otherwise, it will display the following message and exit: “You must be logged in as an administrator when installing this program.”</p><p>当设置为admin（默认值）时，仅当用户是Administrators组的成员时，安装程序才会运行。 否则，它将显示以下消息并退出：“安装此程序时，您必须以管理员身份登录。”</p><p>When set to poweruser, Setup will only run if the user is a member of the Administrators or Power Users groups. Otherwise, it will display the following message and exit: “You must be logged in as an administrator or as a member of the Power Users group when installing this program.”</p><p>设置为poweruser时，仅当用户是Administrators或Power Users组的成员时，安装程序才会运行。 否则，它将显示以下消息并退出：“安装此程序时，您必须以管理员或Power Users组成员的身份登录。”</p><p>When set to none Setup will not check the user’s group membership. Do not use this setting unless you are sure your installation will run successfully on unprivileged accounts.</p><p>设置为none时，安装程序将不检查用户的组成员身份。 除非您确定安装将在非特权帐户上成功运行，否则不要使用此设置。</p><p>When set to lowest Setup will not check the user’s group membership. Additionally, the uninstall info root key will always be HKEY_CURRENT_USER, and the “common” forms of the Shell Folder constants are mapped to the “user” forms, even if administrative privileges are available. Do not use this setting unless you are sure your installation will run successfully on unprivileged accounts.</p><p>设置为最低时，安装程序将不检查用户的组成员身份。 此外，卸载信息的根密钥将始终为HKEY_CURRENT_USER，并且即使具有管理特权，Shell文件夹常量的“公共”形式也将映射到“用户”形式。 除非您确定安装将在非特权帐户上成功运行，否则不要使用此设置。</p><p><strong>On Windows 95/98/Me</strong></p><p>This directive has no effect on these versions of Windows.</p><p>该指令对这些版本的Windows无效。</p><h3 id="以管理员身份安装和非管理员身份安装的区别"><a href="#以管理员身份安装和非管理员身份安装的区别" class="headerlink" title="以管理员身份安装和非管理员身份安装的区别"></a>以管理员身份安装和非管理员身份安装的区别</h3><p>An installation can run in one of two modes: administrative or non administrative. Which mode is selected is specified by the <a href="http://www.jrsoftware.org/ishelp/topic_setup_privilegesrequired.htm" target="_blank" rel="noopener">PrivilegesRequired</a> and <a href="http://www.jrsoftware.org/ishelp/topic_setup_privilegesrequiredoverridesallowed.htm" target="_blank" rel="noopener">PrivilegesRequiredOverridesAllowed</a> [Setup] section directives.</p><p>In administrative install mode:</p><ul><li>The <code>{group}</code> folder is created in the <em>All Users</em> profile.</li><li>The “auto” form of the directory and Shell Folder constants is mapped to the “common” form.</li><li>The <a href="http://www.jrsoftware.org/ishelp/topic_registrysection.htm" target="_blank" rel="noopener">HKA</a> and uninstall info root keys will be HKEY_LOCAL_MACHINE.</li></ul><p>In non administrative install mode:</p><ul><li>The <code>{group}</code> folder is created in the current user’s profile.</li><li>The “auto” form of the directory and Shell Folder constants is mapped to the “user” form.</li><li>The <a href="http://www.jrsoftware.org/ishelp/topic_registrysection.htm" target="_blank" rel="noopener">HKA</a> and uninstall info root keys will be HKEY_CURRENT_USER.</li></ul><p><strong>Notes:</strong></p><p>Regardless of the version of Windows, if the installation is running in administrative install mode then you should be careful about making any per-user area changes: such changes may not achieve what you are intending. The compiler will warn you about this, which can be disabled using <a href="http://www.jrsoftware.org/ishelp/topic_setup_useduserareaswarning.htm" target="_blank" rel="noopener">UsedUserAreasWarning</a>.</p><p>无论Windows的版本如何，如果安装均以管理安装模式运行，则应谨慎进行每个用户区域的更改：此类更改可能无法实现您的预期。 编译器将对此警告，可以使用<a href="http://www.jrsoftware.org/ishelp/topic_setup_useduserareaswarning.htm" target="_blank" rel="noopener">UsedUserAreasWarning</a>禁用。</p><p>If the installation is running in non administrative install mode, but administrative privileges are available anyway then Setup or the [Code] section might still make use of these privileges. For this reason the uninstaller will always be marked as requiring administrative privileges in this case, just as if the installation was running in administrative install mode.</p><p>如果安装程序在非管理安装模式下运行，但是仍然具有管理特权，则安装程序或[Code]部分可能仍会使用这些特权。 因此，在这种情况下，卸载程序将始终被标记为需要管理特权，就像安装在管理安装模式下运行一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Inno Setup 相关" scheme="http://yoursite.com/categories/Inno-Setup-%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Inno Setup" scheme="http://yoursite.com/tags/Inno-Setup/"/>
    
      <category term="管理员身份" scheme="http://yoursite.com/tags/%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>Python 杂记之 根据版本号自动调用泛函数</title>
    <link href="http://yoursite.com/2019/04/25/0807-ma-auto-generic-function/"/>
    <id>http://yoursite.com/2019/04/25/0807-ma-auto-generic-function/</id>
    <published>2019-04-25T00:11:08.000Z</published>
    <updated>2019-04-25T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><p>在未来使用中，窗口的表现形式可能根据版本的不同而不同，但又需要同时要保证代码的向下兼容，也就说可以不断地添加了新的窗口，那老用户的老版本也应该能够继续使用。所以要根据版本信息进行代码（至少是窗体生成部分的代码）的调度。</p><ol><li><p>调度方式1， 传统设计理念中，也就是预定义一部分类方法，在根据实际需求，用字典索引的方式查找类方法或者函数。如下，</p><ul><li><p>可以如下方式进行调度:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p1</span><span class="params">(args)</span>:</span></span><br><span class="line">    whatever</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p2</span><span class="params">(more args)</span>:</span></span><br><span class="line">    whatever</span><br><span class="line"></span><br><span class="line">myDict = &#123;</span><br><span class="line">    <span class="string">"P1"</span>: p1,</span><br><span class="line">    <span class="string">"P2"</span>: p2,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"Pn"</span>: pn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMain</span><span class="params">(name)</span>:</span></span><br><span class="line">    myDict[name]()</span><br></pre></td></tr></table></figure></li><li><p>或者以下列方式进行调度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMain</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ExecP1</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ExecP2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ExecP3</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ExecPn</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    locals()[<span class="string">'Exec'</span> + key]()</span><br></pre></td></tr></table></figure><p>两种的调度思路是一致的。</p></li></ul></li><li><p>调度方式2， Python标准库种有一个functools模块，该模块可以为可调用对象定义高阶函数和操作。即，依据现有函数定义新的函数。我们实现的方式运用了partial函数和singledispatch函数，parital由于定义偏函数，也就是为了固定函数或者方法的一个参数，在该实现方式种用于向Event的Handler传递第二个参数。singledispatch是用于函数调度，即将函数装饰为泛函数。其根据参数的数据类型实现函数的自主调度。因为我们要实现类方法根据不同的版本进行自主调度，就意味着需要将版本作为一种新的数据类型。</p><ul><li><p>基本代码如下：</p><p>```python import wx import wx.adv from sys import modules from functools import singledispatch, update_wrapper, partial</p><p>def methdispatch(func): dispatcher = singledispatch(func) def wrapper(_args, **kw): return dispatcher.dispatch(args[1].<strong>class</strong>)(_args, **kw) wrapper.register = dispatcher.register update_wrapper(wrapper, func) return wrapper</p><p>thisModule = modules[<strong>name</strong>]</p><p><strong>assign the new types inodule level m</strong></p><p>setattr(thisModule, ‘v1_20’, type(‘v1_20’, (object,), {})) setattr(thisModule, ‘v1_30’, type(‘v1_30’, (object,), {})) setattr(thisModule, ‘v1_40’, type(‘v1_40’, (object,), {})) setattr(thisModule, ‘v1_50’, type(‘v1_50’, (object,), {})) setattr(thisModule, ‘v1_60’, type(‘v1_60’, (object,), {}))</p></li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">class ClassDialog(wx.Dialog):</span><br><span class="line"></span><br><span class="line">    def __init__(self, parent, title&#x3D;&quot;Test Demo&quot;, size&#x3D;wx.DefaultSize, pos&#x3D;wx.DefaultPosition, style&#x3D;wx.DEFAULT_DIALOG_STYLE, strVersion&#x3D;&quot;v1_20&quot;, name&#x3D;&quot;TestDemo&quot;):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        strVersion, format v1_20</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        wx.Dialog.__init__(self, parent, wx.ID_ANY, title,</span><br><span class="line">                               size&#x3D;size,</span><br><span class="line">                               pos&#x3D;pos,</span><br><span class="line">                               style&#x3D;style,</span><br><span class="line">                               name&#x3D;name)</span><br><span class="line">        try:</span><br><span class="line">            self.objVersion &#x3D; eval(strVersion)()</span><br><span class="line">        except:</span><br><span class="line">            self.objVersion &#x3D; None</span><br><span class="line">        self.CreateWidgets(self.objVersion)</span><br><span class="line"></span><br><span class="line">    @methdispatch</span><br><span class="line">    def CreateWidgets(self, objVersion):  # @UnusedVariable</span><br><span class="line">        self.panel &#x3D; wx.Panel(self)</span><br><span class="line">        vBoxSizer &#x3D; wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        self.quote &#x3D; wx.StaticText(self.panel, label&#x3D;&quot;Your quote: Default &quot;, pos&#x3D;(20, 30))</span><br><span class="line">        vBoxSizer.Add(self.quote, 5)</span><br><span class="line">        self.btn &#x3D; wx.Button(self.panel, wx.ID_ANY, size&#x3D;wx.DefaultSize, label&#x3D;&quot;Test&quot;)</span><br><span class="line">        vBoxSizer.Add(self.btn, 1)</span><br><span class="line">        self.panel.SetSizer(vBoxSizer)</span><br><span class="line">        self.btn.Bind(wx.EVT_BUTTON, partial(self.OnButtonClicked, self.objVersion))</span><br><span class="line"></span><br><span class="line">    @CreateWidgets.register(v1_20)  # @UndefinedVariable</span><br><span class="line">    def _(self, objVersion):  # @UnusedVariable</span><br><span class="line">        self.panel &#x3D; wx.Panel(self)</span><br><span class="line">        vBoxSizer &#x3D; wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        self.quote &#x3D; wx.StaticText(self.panel, label&#x3D;&quot;Your quote: 1.20 &quot;, pos&#x3D;(20, 30))</span><br><span class="line">        vBoxSizer.Add(self.quote, 5)</span><br><span class="line">        self.btn &#x3D; wx.Button(self.panel, wx.ID_ANY, size&#x3D;wx.DefaultSize, label&#x3D;&quot;Test&quot;)</span><br><span class="line">        vBoxSizer.Add(self.btn, 1)</span><br><span class="line">        self.panel.SetSizer(vBoxSizer)</span><br><span class="line">        self.btn.Bind(wx.EVT_BUTTON, partial(self.OnButtonClicked, self.objVersion))</span><br><span class="line"></span><br><span class="line">    @CreateWidgets.register(v1_30)  # @UndefinedVariable</span><br><span class="line">    def _(self, objVersion):  # @UnusedVariable @DuplicatedSignature</span><br><span class="line">        self.panel &#x3D; wx.Panel(self)</span><br><span class="line">        vBoxSizer &#x3D; wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        self.quote &#x3D; wx.StaticText(self.panel, label&#x3D;&quot;Your quote: 1.30 &quot;, pos&#x3D;(20, 30))</span><br><span class="line">        vBoxSizer.Add(self.quote, 5)</span><br><span class="line">        self.btn &#x3D; wx.Button(self.panel, wx.ID_ANY, size&#x3D;wx.DefaultSize, label&#x3D;&quot;Test&quot;)</span><br><span class="line">        vBoxSizer.Add(self.btn, 1)</span><br><span class="line">        self.panel.SetSizer(vBoxSizer)</span><br><span class="line">        self.btn.Bind(wx.EVT_BUTTON, partial(self.OnButtonClicked, self.objVersion))</span><br><span class="line"></span><br><span class="line">    @methdispatch </span><br><span class="line">    def OnButtonClicked(self, objVersion, event):  # @UnusedVariable</span><br><span class="line">        print(&quot;aaaaa&quot;)</span><br><span class="line"></span><br><span class="line">    @OnButtonClicked.register(v1_20)  # @UndefinedVariable</span><br><span class="line">    def _(self, objVersion, event):  # @UndefinedVariable @DuplicatedSignature @UnusedVariable</span><br><span class="line">        print(event.EventObject.Name)</span><br><span class="line">        print(&quot;bbbbb&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SubClassDialog(ClassDialog):</span><br><span class="line">    def __init__(self, parent, title&#x3D;&quot;Test Demo&quot;, size&#x3D;wx.DefaultSize, pos&#x3D;wx.DefaultPosition, style&#x3D;wx.DEFAULT_DIALOG_STYLE, strVersion&#x3D;&quot;v1_20&quot;, name&#x3D;&quot;TestDemo&quot;):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        strVersion, format v1_20</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ClassDialog.__init__(self, parent, title&#x3D;title, size&#x3D;size, pos&#x3D;pos, style&#x3D;style, strVersion&#x3D;strVersion, name&#x3D;name)  # @UndefinedVariable</span><br><span class="line"></span><br><span class="line">    @ClassDialog.CreateWidgets.register(v1_40)  # @UndefinedVariable</span><br><span class="line">    def _(self, objVersion):  # @DuplicatedSignature @UnusedVariable</span><br><span class="line">        print(&quot;1.40&quot;)</span><br><span class="line"></span><br><span class="line">    @ClassDialog.CreateWidgets.register(v1_50)  # @UndefinedVariable</span><br><span class="line">    def _(self, objVersion):  # @DuplicatedSignature @UnusedVariable</span><br><span class="line">        print(&quot;1.50&quot;)</span><br><span class="line"></span><br><span class="line">class MyFrame(wx.Frame):</span><br><span class="line">    &quot;&quot;&quot; We simply derive a new class of Frame. &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, parent, title):  # @DuplicatedSignature</span><br><span class="line">        wx.Frame.__init__(self, parent, title&#x3D;title, size&#x3D;(200,100))</span><br><span class="line">        dlg&#x3D;SubClassDialog(self, strVersion&#x3D;&quot;v1_x0&quot;)</span><br><span class="line">        res &#x3D; dlg.ShowModal()</span><br><span class="line">        #self.Show(True)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    app &#x3D; wx.App(False)</span><br><span class="line">    frame &#x3D; MyFrame(None, &#39;Small editor&#39;)  # @UnusedVariable</span><br><span class="line">    app.MainLoop()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p> 在日常实践种singledispatch都是用来调度函数的，如果直接用在类方法上，会出现输入参数异常的问题。在这里我们就需要重新定义singledispatch进而得到一个methdispatch的函数。因为类方法的第一个参数为self即实例，所以我们要在函数种dispatch()第二个个参数。检查其数据类型然后调度注册的函数。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">methdispatch</span><span class="params">(func)</span>:</span></span><br><span class="line">    dispatcher = singledispatch(func)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> dispatcher.dispatch(args[<span class="number">1</span>].__class__)(*args, **kw)</span><br><span class="line">    wrapper.register = dispatcher.register</span><br><span class="line">    update_wrapper(wrapper, func)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p> 为了实现类方法依照版本类型自主调度，上文中说到，我们要将版本注册成新的数据类型，或者类。在未来任何需要新的版本，都要将该版本好吧注册成新的类，代码如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thisModule = modules[__name__]</span><br><span class="line"><span class="comment"># assign the new types inodule level m</span></span><br><span class="line">setattr(thisModule, <span class="string">'v1_20'</span>, type(<span class="string">'v1_20'</span>, (object,), &#123;&#125;))</span><br><span class="line">setattr(thisModule, <span class="string">'v1_30'</span>, type(<span class="string">'v1_30'</span>, (object,), &#123;&#125;))</span><br><span class="line">setattr(thisModule, <span class="string">'v1_40'</span>, type(<span class="string">'v1_40'</span>, (object,), &#123;&#125;))</span><br><span class="line">setattr(thisModule, <span class="string">'v1_50'</span>, type(<span class="string">'v1_50'</span>, (object,), &#123;&#125;))</span><br><span class="line">setattr(thisModule, <span class="string">'v1_60'</span>, type(<span class="string">'v1_60'</span>, (object,), &#123;&#125;))</span><br></pre></td></tr></table></figure><p> 普通的类方法可以用如下的代码实现调度，如果采用上述的方式进行版本数据类型的声明，一些IDE并不能够自动找到新注册的数据类型，就会出现该类型未找到的错，如果使用Eclipse就需要添加特别注释@UndefinedVariable：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateWidgets.register(v1_30)  # @UndefinedVariable</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(self, objVersion)</span>:</span>  <span class="comment"># @UnusedVariable @DuplicatedSignature</span></span><br><span class="line">    self.panel = wx.Panel(self)</span><br><span class="line">    vBoxSizer = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">    self.quote = wx.StaticText(self.panel, label=<span class="string">"Your quote: 1.30 "</span>, pos=(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">    vBoxSizer.Add(self.quote, <span class="number">5</span>)</span><br><span class="line">    self.btn = wx.Button(self.panel, wx.ID_ANY, size=wx.DefaultSize, label=<span class="string">"Test"</span>)</span><br><span class="line">    vBoxSizer.Add(self.btn, <span class="number">1</span>)</span><br><span class="line">    self.panel.SetSizer(vBoxSizer)</span><br><span class="line">    self.btn.Bind(wx.EVT_BUTTON, partial(self.OnButtonClicked, self.objVersion))</span><br></pre></td></tr></table></figure><p> 针对一些特别的类方法如，事件处理函数，就要用到partial函数，代码如下。需要注意的是在这里partial固定的是类方法OnButtonClicked的第一个参数，第二个参数是Event。 理解了这些，我们就可以根据版本的不同调度同一事件的不同时间的处理方法了。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.btn.Bind(wx.EVT_BUTTON, partial(self.OnButtonClicked, self.objVersion))</span><br></pre></td></tr></table></figure><p> 注册同一事件处理函数的泛函数方法如下，泛函数的名称可以自由定义，但是_在这里确实是一个很好的选择，如果某一版本的泛函数没被注册，就会使用函数的本体:</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@methdispatch </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnButtonClicked</span><span class="params">(self, objVersion, event)</span>:</span>  <span class="comment"># @UnusedVariable</span></span><br><span class="line">    print(<span class="string">"aaaaa"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnButtonClicked.register(v1_20)  # @UndefinedVariable</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(self, objVersion, event)</span>:</span>  <span class="comment"># @DuplicatedSignature @UnusedVariable</span></span><br><span class="line">    print(event.EventObject.Name)</span><br><span class="line">    print(<span class="string">"bbbbb"</span>)</span><br></pre></td></tr></table></figure><p> 上述的内容都是在一个Python种的使用情况，下面我们介绍一下如何跨模块实现上述内容，在跨模块使用该调度方式的时候，需要注意要从基本模块加载版本的数据类型，在注册泛函数的时候写法也于在同一模块种的不同，本例种：@ClassDialog.CreateWidgets.register(v1_60)，从类名，类方法名再进而注册版本类型。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wx</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> ClassDialog, v1_60 <span class="comment"># @UnusedImport @UnresolvedImport</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClassDialogInExtraModule</span><span class="params">(ClassDialog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent, title=<span class="string">"Test Demo"</span>, size=wx.DefaultSize, pos=wx.DefaultPosition, style=wx.DEFAULT_DIALOG_STYLE, strVersion=<span class="string">"v1_20"</span>, name=<span class="string">"TestDemo"</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        strVersion, format v1_20</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ClassDialog.__init__(self, parent, title=title, size=size, pos=pos, style=style, strVersion=strVersion, name=name)  <span class="comment"># @UndefinedVariable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @ClassDialog.CreateWidgets.register(v1_60)  # @UndefinedVariable</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(self, objVersion)</span>:</span>  <span class="comment"># @UnusedVariable @DuplicatedSignature</span></span><br><span class="line">        self.panel = wx.Panel(self)</span><br><span class="line">        vBoxSizer = wx.BoxSizer(wx.VERTICAL)</span><br><span class="line">        self.quote = wx.StaticText(self.panel, label=<span class="string">"Your quote: 1.60 "</span>, pos=(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">        vBoxSizer.Add(self.quote, <span class="number">5</span>)</span><br><span class="line">        self.btn = wx.Button(self.panel, wx.ID_ANY, size=wx.DefaultSize, label=<span class="string">"Test"</span>)</span><br><span class="line">        vBoxSizer.Add(self.btn, <span class="number">1</span>)</span><br><span class="line">        self.panel.SetSizer(vBoxSizer)</span><br><span class="line">        self.btn.Bind(wx.EVT_BUTTON, partial(self.OnButtonClicked, self.objVersion))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span><span class="params">(wx.Frame)</span>:</span></span><br><span class="line">    <span class="string">""" We simply derive a new class of Frame. """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent, title)</span>:</span>  <span class="comment"># @DuplicatedSignature</span></span><br><span class="line">        wx.Frame.__init__(self, parent, title=title, size=(<span class="number">200</span>,<span class="number">100</span>))</span><br><span class="line">        dlg=SubClassDialogInExtraModule(self, strVersion=<span class="string">"v1_60"</span>)</span><br><span class="line">        res = dlg.ShowModal()  <span class="comment"># @UnusedVariable</span></span><br><span class="line">        <span class="comment">#self.Show(True)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = wx.App(<span class="literal">False</span>)</span><br><span class="line">    frame = MyFrame(<span class="literal">None</span>, <span class="string">'Small editor'</span>)  <span class="comment"># @UnusedVariable</span></span><br><span class="line">    app.MainLoop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p> 上述就是使用functools种的两个函数实现依据不同版本调度不同的泛函数的全部内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 8. Python 杂记" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="自动调用" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8/"/>
    
      <category term="泛函数" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 杂记之 如何确定两个字符串的相似度</title>
    <link href="http://yoursite.com/2018/12/25/0806-ma-string-similarity/"/>
    <id>http://yoursite.com/2018/12/25/0806-ma-string-similarity/</id>
    <published>2018-12-25T00:11:08.000Z</published>
    <updated>2018-12-25T00:11:08.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Python 相关 - 8. Python 杂记" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="相似度" scheme="http://yoursite.com/tags/%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 杂记之 不同版本间剪切板代码兼容性问题</title>
    <link href="http://yoursite.com/2018/12/20/0805-ma-compability-issue/"/>
    <id>http://yoursite.com/2018/12/20/0805-ma-compability-issue/</id>
    <published>2018-12-20T00:11:08.000Z</published>
    <updated>2018-12-20T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="剪切板的基本操作"><a href="#剪切板的基本操作" class="headerlink" title="剪切板的基本操作"></a>剪切板的基本操作</h2><p>在Python的实际应用中有时候会遇到对剪切板进行操作的问题。剪切板的基本操作需求如下：</p><ul><li>获取剪切板中的内容。</li><li>向剪切板中注入内容。</li><li>清除剪切板的内容。</li></ul><p>使用Python对剪切板进行操作，可以使用tkinter和ctypes这两个标准库。或者使用Qt或者wxpython这些第三方模块（库）来实现。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/LNbO7CDlxmad3eibCibvYHAE43LAlxR0KtSSXwcJAlficsqnvlLNnicHfJPN2C4VYBICeeVI71H81mkWvViaMdQ4KDw/640?wx_fmt=png" alt="img"></p><h2 id="使用ctypes标准库操作剪切板"><a href="#使用ctypes标准库操作剪切板" class="headerlink" title="使用ctypes标准库操作剪切板"></a>使用ctypes标准库操作剪切板</h2><p>使用tkinter标准库或者第三方的Qt或者wxpython，这些实现方式常常是用在在<strong>图形界面化</strong>的项目中的，比如结合按钮事件等。使用ctypes就可以直接在<strong>非图形化界面</strong>项目中实现对剪切板的操作。或者使用pyperclip第三方模块也可实现跨平台的普通项目中对剪切板的操作，基本实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">CF_TEXT = <span class="number">1</span></span><br><span class="line">kernel32 = ctypes.windll.kernel32</span><br><span class="line">user32 = ctypes.windll.user32</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">    rts = <span class="string">""</span></span><br><span class="line">    user32.OpenClipboard(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> user32.IsClipboardFormatAvailable(CF_TEXT):</span><br><span class="line">        data = user32.GetClipboardData(CF_TEXT)</span><br><span class="line">        data_locked = kernel32.GlobalLock(data)</span><br><span class="line">        text = ctypes.c_char_p(data_locked)</span><br><span class="line">        print(text.value)</span><br><span class="line">        rts = text.value</span><br><span class="line">        kernel32.GlobalUnlock(data_locked)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'no text in clipboard'</span>)</span><br><span class="line">    user32.CloseClipboard()</span><br><span class="line">    <span class="keyword">return</span> rts</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(text)</span>:</span></span><br><span class="line">    GMEM_DDESHARE = <span class="number">0x2000</span></span><br><span class="line">    user32.OpenClipboard(<span class="number">0</span>)</span><br><span class="line">    user32.EmptyClipboard()</span><br><span class="line">    hCd = ctypes.windll.kernel32.GlobalAlloc(GMEM_DDESHARE, len(bytes(text))+<span class="number">1</span>)</span><br><span class="line">    pchData = ctypes.windll.kernel32.GlobalLock(hCd)</span><br><span class="line">    ctypes.cdll.msvcrt.strcpy(ctypes.c_char_p(pchData), bytes(text))</span><br><span class="line">    kernel32.GlobalUnlock(hCd)</span><br><span class="line">    user32.SetClipboardData(CF_TEXT, hCd)</span><br><span class="line">    user32.CloseClipboard()</span><br></pre></td></tr></table></figure><p>上述代码中，比较难以理解的应该是GlobalLock和GlobalUnlock，如果有C++的开发背景应该很容易理解这两个函数。简单解释：</p><blockquote><p>GlobalLock()函数 说明：锁定内存中指定的内存块，并返回一个地址值，令其指向内存块的起始处。除非用 GlobalUnlock 函数将内存块解锁，否则地址会一直保持有效。Windows 为每个内存对象都维持着一个锁定计数。对这个函数的每次调用都应有一个对应的 GlobalUnlock 调用 返回值 Long，如成功，返回内存块的地址；如出错，或者这是一个已被丢弃的“可丢弃”内存块，则返回零。通常我们在编程的时候，给应用程序分配的内存都是可以移动的或者是可以丢弃的，这样能使有限的内存资源充分利用，所以，在某一个时候我们分配 的那块内存的地址是不确定的，因为他是可以移动的，所以得先锁定那块内存块，这儿应用程序需要调用API函数GlobalLock函数来锁定句柄。如下：lpMem=GlobalLock(hMem)（数据类型应该是指针类型）; 这样应用程序才能存取这块内存。</p></blockquote><h2 id="剪切板操作的兼容性问题"><a href="#剪切板操作的兼容性问题" class="headerlink" title="剪切板操作的兼容性问题"></a>剪切板操作的兼容性问题</h2><p>上述代码我在公司的项目中也有使用。但是自从公司决定将软件中内嵌的Python2.7升级到Python3.7之后，类似上述的代码就不能在继续运行了。经过调试之后，发现了问题所在，请看下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_clipboard_text</span><span class="params">()</span>:</span></span><br><span class="line">    user32.OpenClipboard(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> user32.IsClipboardFormatAvailable(CF_TEXT):</span><br><span class="line">        data = user32.GetClipboardData(CF_TEXT)</span><br><span class="line">        data_locked = kernel32.GlobalLock(data)</span><br><span class="line">        text = ctypes.c_char_p(data_locked)</span><br><span class="line">        value = text.value <span class="comment"># 问题所在位置。</span></span><br><span class="line">        kernel32.GlobalUnlock(data_locked)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    user32.CloseClipboard()</span><br></pre></td></tr></table></figure><p>在上述代码中，在调试代码时，代码可以运行至带有注释的这一行的前一行。当试图尝试使用便利text时，程序就会出错，从而引发崩溃。可以肯定的是text变量并不为None，在一开始一直以为是锁定内存带来的问题。但是最后发现整个代码都有问题的。</p><p>在不断尝试之后，项目背景是，剪切板的中不会存在特殊字符或者宽字符。本着最少代码修改量就能解决问题的原则，以及“简单胜过复杂”的设计哲学。我们用下列代码解决了这部分代码对Python3的兼容。</p><p><strong>“Simple is better than complicated”</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kernel32.GlobalLock.argtypes = [ctypes.c_void_p]</span><br><span class="line">kernel32.GlobalLock.restype = ctypes.c_void_p</span><br><span class="line">kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]</span><br><span class="line">user32.GetClipboardData.restype = ctypes.c_void_p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_clipboard_text</span><span class="params">()</span>:</span></span><br><span class="line">    user32.OpenClipboard(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> user32.IsClipboardFormatAvailable(CF_TEXT):</span><br><span class="line">            data = user32.GetClipboardData(CF_TEXT)</span><br><span class="line">            data_locked = kernel32.GlobalLock(data)</span><br><span class="line">            text = ctypes.c_char_p(data_locked)</span><br><span class="line">            value = text.value</span><br><span class="line">            kernel32.GlobalUnlock(data_locked)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        user32.CloseClipboard()</span><br></pre></td></tr></table></figure><p>在使用函数的时候，只要提前申明了函数参数的数据类型，和函数返回值的数据类型。就解决了兼容性问题。虽然解决了问题，但是总觉得有种知其然不知所以然的感觉。为什么Python2中不需要声明，而Python3中却需要。经过不断地查找，找到了下面的解决方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> ctypes.wintypes <span class="keyword">as</span> w</span><br><span class="line"></span><br><span class="line">CF_UNICODETEXT = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">u32 = ctypes.WinDLL(<span class="string">'user32'</span>)</span><br><span class="line">k32 = ctypes.WinDLL(<span class="string">'kernel32'</span>)</span><br><span class="line"></span><br><span class="line">OpenClipboard = u32.OpenClipboard</span><br><span class="line">OpenClipboard.argtypes = w.HWND,</span><br><span class="line">OpenClipboard.restype = w.BOOL</span><br><span class="line">GetClipboardData = u32.GetClipboardData</span><br><span class="line">GetClipboardData.argtypes = w.UINT,</span><br><span class="line">GetClipboardData.restype = w.HANDLE</span><br><span class="line">GlobalLock = k32.GlobalLock</span><br><span class="line">GlobalLock.argtypes = w.HGLOBAL,</span><br><span class="line">GlobalLock.restype = w.LPVOID</span><br><span class="line">GlobalUnlock = k32.GlobalUnlock</span><br><span class="line">GlobalUnlock.argtypes = w.HGLOBAL,</span><br><span class="line">GlobalUnlock.restype = w.BOOL</span><br><span class="line">CloseClipboard = u32.CloseClipboard</span><br><span class="line">CloseClipboard.argtypes = <span class="literal">None</span></span><br><span class="line">CloseClipboard.restype = w.BOOL</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_clipboard_text</span><span class="params">()</span>:</span></span><br><span class="line">    text = <span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span> OpenClipboard(<span class="literal">None</span>):</span><br><span class="line">        h_clip_mem = GetClipboardData(CF_UNICODETEXT)</span><br><span class="line">        text = ctypes.wstring_at(GlobalLock(h_clip_mem))</span><br><span class="line">        GlobalUnlock(h_clip_mem)</span><br><span class="line">        CloseClipboard()</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line">print(get_clipboard_text())</span><br></pre></td></tr></table></figure><p>乍一看，很复杂，其实其实现过程和第一个解决方案相似，而且上述的代码够同时在Python2.x和Python3.x中完美运行，也同时支持ascii与unicode字符，算是一个完美的解决方案。</p><p>这个解决方案的提供者Mark Tolonen也解释道，由于Python3是64位的，如果我们在Python3.x的环境下使用原来在Python2.x中的代码。默认情况下，我们传递是句柄就是c_int(32bit)的，存储长度不够。超出会存在负值，导致代码不兼容的主要问题就在这儿。</p><p>kernel内核和windows的句柄都是32位的。如果在64位环境中使用这些句柄就会存在负值，为了避免这种情况发生，就应该将这些句柄扩展至64位。而且一些句柄实际上是内存的地址，例如HMODULE和HGLOBAL，以及GlobalLock的返回结果也应该得到扩展。总的来讲，在处理句柄和指针的时候总是声明参数argtypes和返回值restype，就可以避免硬编码实现细节和假设。</p><p>学无止境，总有高手，在这些高手的解释中也学习到了很多，了解一些问题出现的根本原因，和这些高手在面对这些问题时所思考的内容。然后学以致用，来提高自己。</p><p>参考目录：</p><p><strong>Stackflow：</strong><a href="https://stackoverflow.com/questions/46132401/read-text-from-clipboard-in-windows-using-ctypes" target="_blank" rel="noopener">https://stackoverflow.com/questions/46132401/read-text-from-clipboard-in-windows-using-ctypes</a></p><p><strong>CSDN：</strong><a href="https://blog.csdn.net/longxin5/article/details/83394388" target="_blank" rel="noopener">https://blog.csdn.net/longxin5/article/details/83394388</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 8. Python 杂记" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="剪切板" scheme="http://yoursite.com/tags/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
      <category term="代码兼容" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>Python 杂记之 实现列表的自加和左移等操作</title>
    <link href="http://yoursite.com/2018/12/15/0804-ma-list-leftadd-selfadd-op/"/>
    <id>http://yoursite.com/2018/12/15/0804-ma-list-leftadd-selfadd-op/</id>
    <published>2018-12-15T00:11:08.000Z</published>
    <updated>2018-12-15T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="列表与操作方法"><a href="#列表与操作方法" class="headerlink" title="列表与操作方法"></a>列表与操作方法</h2><p>列表<strong>list</strong>是Python语言中的标准数据类型，进一步讲list是一种可变的序列类型，不可变的有tuple和range（注：Python 3.x中xrange已经不存在了）。<strong>可变序列类型</strong>，<strong>可变</strong>就是长度可以改变，所含元素数值可以改变，元素数据类型可以改变；<strong>序列</strong>意指成员有序排列，可以通过索引访问元素。既然是序列类型，就一定可以迭代（for 循环），所以列表是<strong>可迭代</strong>的对象，请注意<strong>可迭代</strong>和<strong>迭代器</strong>的差异。</p><p>列表的常用操作包括，索引，切片，改变与排序。而这几种操作要属<strong>改变</strong>最多样。改变包括，一、<strong>长度改变</strong>，成员的<strong>添加</strong>（常用方法append，insert和extend）与<strong>删除</strong>（常用方法pop与remove）。二、<strong>数值改变</strong>，通过索引访问与重新赋值来实现。</p><h2 id="列表操作的延伸思考"><a href="#列表操作的延伸思考" class="headerlink" title="列表操作的延伸思考"></a>列表操作的延伸思考</h2><p>由于上一篇文章是与运算符相关，所以在准备文字的时候就思索，作为标准数据类型的列表，能和它组合使用的运算符都有什么呢？今天我就和大家一起总结，共同学习一下。</p><p>一般情况下，Python中列表只能与➕操作符组合使用，前提是➕号左右都是序列类型。可能别的教程里面规定➕左右都应该是一样的列表类型。我们今天扩展一下，定义：➕号左右都是序列类型。</p><ul><li>当加号➕右侧为列表，或者range()时，代码表现符合正常预期，请参看下面例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m3 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 + m3</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 + range(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = range(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(ss)</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 + (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate list (<span class="keyword">not</span> <span class="string">"tuple"</span>) to list</span><br></pre></td></tr></table></figure><p>List作为唯一的可变序列类型，而且与加号左侧数据类型一直，它的加法运算正常且容易理解。range， str与tuple是不可变的数据类型，理论上与列表相加时肯定会出错的，但是在Python 2.x 中却没有问题，结果如上。其原因为: Python 2.x 中range返回的是一个列表。而在Python 3.x 中这样写就会引发异常，参考如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 + range(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate list (<span class="keyword">not</span> <span class="string">"range"</span>) to list</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = range(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(ss)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">range</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>因为Python 3.x 中返回的是一个真正的range类实例，是一个不可变的序列类型。</p><ul><li>当加号➕右侧为其它序列类型，即不可变序列类型，如 tuple 或 str 时，请参看下面例子：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 += <span class="string">"hello"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = m2 + <span class="string">"hello"</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate list (<span class="keyword">not</span> <span class="string">"str"</span>) to list</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 += (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m2 = m2 + (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate list (<span class="keyword">not</span> <span class="string">"tuple"</span>) to list</span><br></pre></td></tr></table></figure><p>理论上肯定不行的，毕竟左右两侧的数据类型不同。但是总会有些意外，有些惊喜。虽然在<strong>运算符</strong>的章节中，我们了解到自加操作符与加法和赋值的组合等效，即 a += 1 等效于 a = a + 1。但是参照上方的例子，我们发现应该在解析运行的时候。两种数据操作方式还是有些不一样的，比如在参与的数据有列表是，<strong>自加</strong>时，因为列表（等号左侧）为可变对象，原则上仅需要本地对象（这里指m2）进行修改，不需要产生新的对象。那么在修改的时候解释器会讲右侧的对象尝试数据类型转换，上述的例子中讲字符穿转换为字符列表，将tuple转换为列表，进而对本地m2对象进行修改，所以我们就实现了所有<strong>序列类型</strong>的加法操作，注意非序列的数据类型不行，是不是有点神奇。</p><h2 id="进一步延伸思考"><a href="#进一步延伸思考" class="headerlink" title="进一步延伸思考"></a>进一步延伸思考</h2><p>上一节，我们通过总结可知：1. 列表的加法操作，并不是全效的加法，因为对数据只能对序列操作，那么如果仅需要添加一个成员的时候，加法操作就不再适用。2. 列表没有减法操作。那么有解决方法吗？了解到Python<strong>万物皆对象</strong>（必定不单身）。那么如果继承列表基本类，创建自有字类，通过重写方法就是实现Python的全效加法于减法。有想法之后就实现一下，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment">#Function is called by + command</span></span><br><span class="line">        self.addObj(obj)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment">#Function is called by - command</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, list) <span class="keyword">or</span> isinstance(obj, tuple):</span><br><span class="line">        <span class="comment">#if isinstance(obj, list) or isinstance(obj, tuple) or isinstance(obj, range): # Python 3.x</span></span><br><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> obj: </span><br><span class="line">                <span class="keyword">return</span> self.__class__([item <span class="keyword">for</span> item <span class="keyword">in</span> self <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> obj])</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> self.__class__([item <span class="keyword">for</span> item <span class="keyword">in</span> self <span class="keyword">if</span> item != obj])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lshift__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment">#Function is called by &lt;&lt; command</span></span><br><span class="line">        self += obj</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iadd__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="comment">#Function is called by += command</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(obj, list) <span class="keyword">or</span> isinstance(obj, tuple):</span><br><span class="line">        <span class="comment">#if isinstance(obj, list) or isinstance(obj, tuple) or isinstance(obj, range): # Python 3.x</span></span><br><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> obj: </span><br><span class="line">                self.addObj(o)</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            self.addObj(obj)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addObj</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        self.append(obj)</span><br></pre></td></tr></table></figure><p>在使用需要注意，由于Python默认的列表类为list，传统的列表赋值方式只能产生list的实例对象，那么如果初始化玩MyList类的实例后，再为实例变量使用传统方式赋值时，那么就会产生新的对象，而且新类的<strong>属性</strong>与<strong>方法</strong>将丢失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> test <span class="keyword">import</span> MyList</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml = MyList([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(ml)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">test</span>.<span class="title">MyList</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; ml = MyList()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(ml)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">test</span>.<span class="title">MyList</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; ml = ["a", "b", "c"]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(ml)</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt;</span><br></pre></td></tr></table></figure><p>实际使用结果如下，因为在加法运算时，我们返回类实例本身，所以列表的值在做加法是会发生变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml = MyList([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml + [<span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml = MyList([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml + [<span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, [<span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml = MyList([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml += [<span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml = MyList([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml + <span class="string">"e"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml - <span class="number">1</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>]  <span class="comment"># 新的列表对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml - [<span class="string">'c'</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>] <span class="comment"># 新的列表对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml &lt;&lt; <span class="string">"e"</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">1</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ml &lt;&lt; [<span class="string">'d'</span>, <span class="string">'f'</span>]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="number">1</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'f'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tt = ml - [<span class="string">'c'</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(tt)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">test</span>.<span class="title">MyList</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>而在做减法运算时，我们创建并返回一个新的类实例，所以减数，即原始列表值不发生改变，请参见上述代码中带注释的内容。有心的同学可能也发现了，我们重写__iadd__()， 实现了我们预期的自加，重写__add__()， 实现了我们预期的加法，重写__sub__()， 实现了我们预期的列表减法运算和重写__lshift__()， 实现了我们预期的列表的左移运算，怎么样是不是也有一点成就感。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在之前的文章中我们介绍了如何动态重写类方法，那么我们的上述的方法能不能也动态地写入基类list中，使其所有实例都有新的方法呢？感兴趣的童鞋可以自己可以试一下。我把结果写出来, 就不再举例分析。<strong>是不行的</strong>，由于基类是由别的语言实现的属于built-in类型，虽然也是动态的类，但是却因为别的语言限制了访问，所以其<em>\</em>iadd__()方法，在实例中是<strong>仅可读的</strong>。所以就没办法实现list基类，这些方法的动态绑定和重写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 8. Python 杂记" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="自加" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python 杂记之 如何动态重写类方法</title>
    <link href="http://yoursite.com/2018/12/10/0803-ma-dynamic-classmethod-override/"/>
    <id>http://yoursite.com/2018/12/10/0803-ma-dynamic-classmethod-override/</id>
    <published>2018-12-10T00:11:08.000Z</published>
    <updated>2018-12-10T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="Python-是动态的编程语言"><a href="#Python-是动态的编程语言" class="headerlink" title="Python 是动态的编程语言"></a>Python 是动态的编程语言</h2><p> 在自己有关Python的第一篇文章中就介绍了Python的特性与优势，在文章中也介绍了其是一种动态的编程语言。在这里我再简单在当前文章中介绍一下，如下：</p><blockquote><p>能够在运行时修改自身程序结构的语言，就属于动态语言。那怎样才算是“运行时修改自身程序结构”捏？比如下面这几个例子都 算：在运行时给某个类增加成员函数及成员变量；在运行时改变某个类的父类；在运行时创建出某个函数.。 Python是可以实现动态类的创建类（在任意代码位置，符合正确的书写格式），或者给类增加删除属性。因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。比如，你可以在函数中创建类，使用class关键字即可。” 既然是一种动态的高级语言，那么就意味着，其是在运行时就能改变其结构的编程语言。这在调试代码时，可以动态实时地改变变量，重写函数等，比起传统的C++与广泛运用的Java具有很强的优势。所叙述的结构包括：函数、变量与对象。已有的函数或方法可以被删除或是其他结构上的变化。</p></blockquote><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p> 最近在工作中遇到了一个问题：现有一Wxpython的Widget类，即继承TextCtrl的自定义类，该类有一个实例方法，在这暂且就称作method_x吧，整个项目都在使用该实例方法，虽然其内在调用关系十分复杂，这也是我一直诟病我们项目代码的地方，但其一直表现良好。我的需求是：在不改变这个类的，也不影响其他代码的的情况下，重写或者重新定义这个方法。这些只并且仅对特定实例有效。</p><p> 首先我能想到的就是继承该类，进而得到一个子类，在子类里面仅Override覆盖该实例方法。这应该是最正常的方法，或者大部分人能想到的方法。可是我又不希望这样做，这样在后期维护的该类的时候还要为子类针对一下改变做出调整。而且在文章中还要import一下。那么有没有别的方法呢？考虑到Python是动态语言，动态调整函数和变量都是自己应用过的，那么这样的动态语言，能不能动态地修改（重写）一个类的实例方法呢？抱着这样的想法，我查阅了一些网页，成功实现了这样的想法，也在完成该任务，解决该问题的过程中更深层的理解了Python这种语言的动态特性。</p><p> 最终我归纳出三种方法，可以实现类的实例方法的动态重写，在此我针对每种方法列出范例代码，并给出运行结果，并对这三种方法进行比较说明，本人并非专家，有见解不足之处，也希望各位高手留言赐教。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p> 使用函数的_<em>get()__内置方法，也是一个描述符，其本质是一个新式类, 在这个新式类中, 至少实现了<em>\</em>_get()_\</em>, __set()__, <em>\</em>delete()__中的一个, 这也被称为描述符协议，其中__get()<em>\</em>:在调用一个属性时被触发。 __get__(self, instance, owner) 定义当描述器的值被取得的时候的行为， instance 是拥有者对象的一个实例。 owner 是拥有者类本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am old func1"</span>        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func1</span><span class="params">(self)</span>:</span>        </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am new func1"</span></span><br><span class="line"></span><br><span class="line">objTest1 = Test()</span><br><span class="line"><span class="keyword">print</span> id(new_func1)</span><br><span class="line">objTest2 = Test()</span><br><span class="line">objTest1.func1()</span><br><span class="line">objTest2.func1() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅对该实例重写这个方法</span></span><br><span class="line"><span class="keyword">print</span> new_func1.__get__(objTest1, Test)</span><br><span class="line">objTest1.func1 = new_func1.__get__(objTest1, Test)</span><br><span class="line">objTest1.func1()</span><br><span class="line">objTest2.func1()</span><br></pre></td></tr></table></figure><p>代码输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\\&gt;python test.py</span><br><span class="line">55131384</span><br><span class="line">I am old func1</span><br><span class="line">Iam old func1</span><br><span class="line">&lt;bound method Test.new_func1 of &lt;__main__.Test instance at 0x0000000002F60C88&gt;&gt;</span><br><span class="line">I am new func1</span><br><span class="line">I am old func1</span><br></pre></td></tr></table></figure><p>那么现在我们来尝试来理解一下这个方法的原理，上文说到__get()__是一个描述符，或称描述器，描述器分为两种，一共是资料描述器（data-descriptor), 一种是非资料描述器(non-data descriptor)。我们在这里使用的是非资料描述器， __get__(self, instance, owner) ，该方法的第二个参数是可选的（非必需）。 上面代码在使用该描述器的时候，就是将函数new_func1()绑定在类Test的实例objTest1上，而等号前面的是objTest1.func1 意味这，要将新绑定的实例方法覆盖到func1上，进而在再次调用实例方法func1()的时候，其实是在调用new_func1()。 该方法很有好处，可以理解为”几乎”是实现了一个方法的覆盖，你可以在新定义的方法中使用关键字self。 但是不能使用关键字super，即不能访问类的父类。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用Python的偏函数，Python的偏函数，与数学意义上的偏函数不同。其偏函数的思想可以理解为绑定了一部分参数的函数，其作用就是减少传入函数，使函数更短，更简洁。在这儿使用偏函数重写实例方法，目的就在与保证第一个参数self的传入。也就是partial()的第二个参数。把new_func1()的第一个参数固定了下来。保证重写的实例方法能访问self关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.m = <span class="string">"message"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am old func1"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func1</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> self.m</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am new func1"</span></span><br><span class="line"></span><br><span class="line">objTest1 = Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(new_func1)</span><br><span class="line"></span><br><span class="line">objTest2 = Test()</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅对该实例重写这个方法</span></span><br><span class="line"><span class="comment">#print new_func1.__get__(objTest1, Test)</span></span><br><span class="line"><span class="comment">#objTest1.func1 = new_func1.__get__(objTest1, Test)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line">objTest1.func1 = partial(new_func1, objTest1)</span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1()</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\\&gt;python test.py</span><br><span class="line">52313336</span><br><span class="line">I am old func1</span><br><span class="line">I am old func1</span><br><span class="line">47500528</span><br><span class="line">47692840</span><br><span class="line">message</span><br><span class="line">I am new func1</span><br><span class="line">I am old func1</span><br></pre></td></tr></table></figure><p>该种方法也简单有效，但是也要从functool中引入partial。也算是一种有效的解决方案。但是其也不能访问关键字super。输出的结果也显示，这样的改变只对特定实例有效。我个人觉得这也是一个简单容易理解的方法，相比较方法一而言，其原理理解起来也并不困难。也不需要更深层次的Python理论知识。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>使用types包中的MethodType 函数。这个方法理解起来就相对更为简单。MethodType可以将一个函数绑定在特定的实例，或者类上。而且该类或者实例，可以没有方法，如果有相同名字的方法，就视为重写。如果绑定在实例上，则完全覆盖其实例的方法。如果绑定在类上，则对所有实例有效。两个绑定方法的区别就在与函数的第二个参数上。 MethodType把方法绑定在类实例上时，每个实例有自己单独的指向区域，互不干扰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="comment">#from functools import partial</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.m = <span class="string">"message"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am old func1"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_func1</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> self.m</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"I am new func1"</span></span><br><span class="line"></span><br><span class="line">objTest1 = Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(new_func1)</span><br><span class="line"></span><br><span class="line">objTest2 = Test()</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1() </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line"><span class="comment"># 仅对该实例重写这个方法</span></span><br><span class="line"><span class="comment">#print new_func1.__get__(objTest1, Test)</span></span><br><span class="line"><span class="comment">#objTest1.func1 = new_func1.__get__(objTest1, Test)</span></span><br><span class="line"><span class="comment">#objTest1.func1 = partial(new_func1, objTest1)</span></span><br><span class="line"></span><br><span class="line">objTest1.func1 = types.MethodType(new_func1, objTest1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(objTest1.func1)</span><br><span class="line"></span><br><span class="line">objTest1.func1()</span><br><span class="line"></span><br><span class="line">objTest2.func1()</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\\&gt;python test.py</span><br><span class="line">60046584</span><br><span class="line">I am old func1</span><br><span class="line">I am old func1</span><br><span class="line">55233776</span><br><span class="line">55233776</span><br><span class="line">message</span><br><span class="line">I am new func1</span><br><span class="line">I am old func1</span><br></pre></td></tr></table></figure><p>从上面的输出结果来看，时候该方法重写实例方法的时候，实例方法的id也没有改变，这是完全意义上方法重写，使用该方法重写类的实例方法，可以访问类的所有关键字。该方法绑定类方法时有一个很有趣区别，因为并不是当前任务需要，这些内容，我们以后在别的文章中进行讨论。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>三种方法以三个不同方向，三种不同的Python背景知识诠释了如何动态的重写（或绑定）一个实例的方法。在分析利弊与结合自己的使用需求，我个人最终选择了方法三, 每种方法都有自己的优缺点，比如方法一就不需要引入别的Python模块。但是至于那个方法是最优的解决方法，那应该是仁者见仁智者见智。这样的经历也是在自己在解决问题的过程中常常经历的。不断地思考探究，也能扎实自己的理论知识，向大拿高手学习的过程中，也为自己在以后遇见问题是，扩展了思考方向。让自己不断拷问自己，同样的需求是不是还有别的解决方案。然后探究，学习，尝试，掌握。 上述内容实自己总结归纳的，总有不足之处，望见谅并指正。</p><p>参考目录：</p><p><strong>Stackoverflow：</strong> <a href="https://stackoverflow.com/questions/394770/override-a-method-at-instance-level" target="_blank" rel="noopener">https://stackoverflow.com/questions/394770/override-a-method-at-instance-level</a></p><p><strong>CSDN Blog:</strong> [<a href="https://blog.csdn.net/yuanyangsdo/article/details/60776612]" target="_blank" rel="noopener">https://blog.csdn.net/yuanyangsdo/article/details/60776612]</a>(</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 8. Python 杂记" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="类方法" scheme="http://yoursite.com/tags/%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python 杂记之 文件扩展名的区别</title>
    <link href="http://yoursite.com/2018/12/05/0802-ma-file-extension/"/>
    <id>http://yoursite.com/2018/12/05/0802-ma-file-extension/</id>
    <published>2018-12-05T00:11:08.000Z</published>
    <updated>2018-12-05T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a><strong>导语</strong></h2><p>虽然Python简单并且容易部署，平时开发时，除了常见的py和pyc文件后缀以外，其实python还有一些别的文件扩展名。我们这篇文章就归纳总结一下所有的与python相关的文件扩展名filename extension（又称后缀名）与各种文件扩展名的文件是如何产生，每种文件文件扩展名的作用。</p><h2 id="与Python有关扩展名"><a href="#与Python有关扩展名" class="headerlink" title="与Python有关扩展名"></a><strong>与Python有关扩展名</strong></h2><ul><li><strong>.py</strong> - 最基本的文件扩展名</li><li><strong>.py3</strong> - (极其少见) Python3 源码文件扩展名. Python3 的正式源码后缀名也为”.py” 不是 “.py3”, 但py3也曾在一些地方出现。</li><li><strong>.pyc</strong> - 源码编译过的文件的扩展名 (字节码)。</li><li><strong>.pyo</strong> - 与pyc一样也是编译过的文件的文件扩展名。优化编译后的程序（相比于.pyc文件更小），也可以提高加载速度。对于嵌入式系统，它可将所需模块编译成.pyo文件以减少容量需求。</li><li><strong>.pyw</strong> - 和py相似，是源码扩展名，跟py扩展名的区别是在windows下双击pyw扩展名的源码会调用pythonw.exe执行源码，这种执行方式不会有命令行窗口，用于GUI程序发布时不需要看到控制台信息的情况。linux环境中，pyw和pyc没有区别。</li><li><strong>.pyx</strong> - Cython 源码，与C/C++源码.c/.cpp相似，不像 Python 语言可直接解释使用的 .py 文件，.pyx 文件必须先被编译成 .c 文件，再编译成 .pyd (Windows 平台) 或 .so (Linux 平台) 文件，才可作为模块 import 导入使用。</li><li><strong>.pyd</strong> - pyd并非从python程序生成，而是其他语言写成的可以被python调用的扩展，例如C++写的（Windows平台dll，Linux 平台.so）动态连接库供python调用。</li><li><strong>.pxd</strong> - Cython 源码头文件，与C/C++源码.h相似。pxd 文件中有 Cython 模块要包含的 Cython 声明 (或代码段)。.pxd 文件可共享外部 C 语言声明，也能包含 C 编译器内联函数。.pxd 文件还可为 .pyx 文件模块提供 Cython 接口，以便其它 Cython 模块可使用比 Python 更高效的协议与之进行通信。可用 cimport 关键字将 .pxd 文件导入 .pyx 模块文件中。</li><li><strong>.pxi</strong> - MyPy存根。</li><li><strong>.pyi</strong> - 存根文件，替代.pxi。 (参考：PEP 484)，如果想在Python编译时实现类型检查，需要用MyPy。 MyPy包含生成.pyi文件的stubgen.py工具。</li><li><strong>.pyz</strong> - Python脚本归档<strong>（参考：PEP 441)</strong>（这是一个包含标准Python脚本头之后的二进制形式的压缩Python脚本（ZIP）的脚本）</li><li><strong>.pywz</strong> - 用于MS-Windows的Python脚本归档<strong>（**</strong>参考：PEP 441)**，如上.pyz。</li><li><strong>.py[cod]</strong> - 版本管理工具Git的忽略文件.gitignore中的通配符，表示需要忽略的文件可能是.pyc，.pyo或.pyd。</li><li><strong>.rpy</strong>- 包含应用程序或框架特定功能的RPython脚本或Python脚本</li><li><strong>.pyde</strong> - 处理使用的Python脚本</li><li><strong>.pyp</strong> - Py4D Python插件</li><li><strong>.pyt</strong> - Python 工具箱 (.pyt) 只是一个基于 ASCII 的文件，该文件定义了工具箱和一个或多个工具。<strong>（参**</strong>考：ArcGIS)**</li></ul><h2 id="扩展名相互关系"><a href="#扩展名相互关系" class="headerlink" title="扩展名相互关系"></a><strong>扩展名相互关系</strong></h2><p>大部分情况下，我们创建的Python脚本都是以.py为文件扩展名。py文件可以通过python命令或者自己写的py脚本进行编译成pyc。使用命令的方法如下，在cmd输入以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m py_compile &#x2F;path&#x2F;to&#x2F;mycode.py #若批量处理.py文件</span><br><span class="line">                                        #则替换为&#x2F;path&#x2F;to&#x2F;&#123;需要生成.pyc的文件1,文件2,...&#125;.py</span><br><span class="line">                                        #或者&#x2F;path&#x2F;to&#x2F;</span><br></pre></td></tr></table></figure><p>也可以在python文件中实现上述过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于文件                                                      </span></span><br><span class="line"><span class="keyword">import</span> py_compile  </span><br><span class="line">py_compile.compile(<span class="string">r'/path/to/mycode.py'</span>) <span class="comment">#.py文件             </span></span><br><span class="line"><span class="comment">#此处尽可能使用raw字符串，从而避免转义的麻烦。                        </span></span><br><span class="line"><span class="comment">#比如，这里不加“r”的话，你就得对斜杠进行转义  #对于文件夹                                                     </span></span><br><span class="line"><span class="keyword">import</span> compileall                                            </span><br><span class="line">compileall.compile_dir(<span class="string">"mylib"</span>, force=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>当然如果希望生成.pyo，则可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -O -m py_compile &#x2F;path&#x2F;to&#x2F;mycode.py #文件或者目录</span><br></pre></td></tr></table></figure><blockquote><p>-O选项，将.pyc文件优化为.pyo文件，而不是将.py 文件优化编译为.pyo文件。优化编译后的文件略微小于.pyc文件， 减少储存的需求。</p></blockquote><p>编译过后的字节码文件.pyc可以反编译成.py文件。反编译软件叫Easy Python Decompiler，可以从网上自己下载，该工具很容易上手，可以反编译一个文件也可以是文件夹。</p><p>虽然编译过后的二进制的字节码可以被反编译。但是如果你不希望自己的代码被别人直接读取，那么可以将字节码.pyc文件打包并公布。虽然与Python的开源精神不相符，但是也算是折中的安全机制。但是值得注意的是：.pyc文件与Python的版本有依赖。即，如果你用Python X编译的pyc文件不能再Python Y中使用，这里的X，Y为代指某些版本，无特定意义。如果强制加载将会引发ImportError异常，异常关键字为Bad magic Number。</p><p>下列是部分版本的Magic Number，全部列表请（参考：<strong>Magic_Nr</strong>)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.5b3: 62111</span><br><span class="line">2.5c1: 62121</span><br><span class="line">2.5c2: 62131</span><br><span class="line">2.6a0: 62151</span><br><span class="line">2.6a1: 62161</span><br><span class="line">2.7a0: 62171</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>Python 3.x 的编译过程是与Python2.x 有区别的，Python 3.x 编译的pyc的时候，会在当前目录里生成一个名为<strong>pycache</strong>的文件夹，为什么会存在该文件夹？Python解释器会将 <em>.py 脚本文件进行编译，并将编译结果保存到<strong>pycache</strong>目录中。下次再执行时，如果解释器发现某个</em> .py 脚本没有修改过，就会跳过编译这一步，直接运行以前生成的保存在 <strong>pycache</strong>文件夹里的 *.pyc 文件。这样就可以大大缩短项目运行前的准备时间；如果你只需执行一个小工程，没关系 忽略这个文件夹就行。而此时你打包pyc的时候就会发现该文件不能正常地被加载，会提示一些错误，常见的错误是解释器和文件路径不匹配。</p><p>为了避免上述的问题，我们可以在编译的时候输入特定的参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m compileall -b test3</span><br></pre></td></tr></table></figure><p>选项-b，指定编译pyc文件的输出到它们的原始位置。（即与Python2中相同）。</p><p>这篇文章我们不过多讨论如何生成Pyd文件，和使用这样的文件，该部分内容，我将在以后的关于在python中使用C/C++代码的文章中详细解释。上述内容是自己在Python应用中遇到过的问题，总有不足之处，望见谅并指正。</p><p>参考目录：</p><p><strong>PEP：441：</strong><a href="https://www.python.org/dev/peps/pep-0484/#stub-files" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0484/#stub-files</a></p><p><strong>PEP：441：</strong><a href="https://www.python.org/dev/peps/pep-0441/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0441/</a></p><p><strong>ERSI ArcGIS：</strong><a href="http://desktop.arcgis.com/zh-cn/arcmap/10.3/analyze/creating-tools/a-quick-tour-of-python-toolboxes.htm" target="_blank" rel="noopener">http://desktop.arcgis.com/zh-cn/arcmap/10.3/analyze/creating-tools/a-quick-tour-of-python-toolboxes.htm</a></p><p><strong>Magic_Nr:</strong> <a href="https://github.com/google/pytype/blob/master/pytype/pyc/" target="_blank" rel="noopener">https://github.com/google/pytype/blob/master/pytype/pyc/</a> magic.py</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 8. Python 杂记" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="文件扩展名" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Python 杂记之 Python不认识0.1</title>
    <link href="http://yoursite.com/2018/12/01/0801-ma-zeropointone/"/>
    <id>http://yoursite.com/2018/12/01/0801-ma-zeropointone/</id>
    <published>2018-12-01T00:11:08.000Z</published>
    <updated>2018-12-01T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="正文导语"><a href="#正文导语" class="headerlink" title="正文导语"></a><strong>正文导语</strong></h2><p>在计算机编程的过程中，常常会涉及到浮点数（小数）的算术运算。稍加留意就会发现，算术运算的结果时常是不正确的。如果程序中有条件语句if加逻辑判断来控制程序执行，由于判断结果也不符合预期，程序就会流向错误的节点。经典例子就是0.1的10次求和与1进行逻辑判断得出的结果为False，遇见相似的问题会把自己急出一身汗，却也弄不个所以然来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span></span><br><span class="line"><span class="number">0.9999999999999999</span></span><br></pre></td></tr></table></figure><h2 id="为什么Pyhon不认识0-1"><a href="#为什么Pyhon不认识0-1" class="headerlink" title="为什么Pyhon不认识0.1"></a><strong>为什么Pyhon不认识0.1</strong></h2><p>通过上面的结果，可以大胆假设：<strong>其实Python不能正确理解0.1，因为若可以，结果就不会出问题</strong>。那么Python是不是不认识0.1呢？这是不是Python 这种编程语言的Bug（错误）？若不注意，在编程时会出现什么样的问题？出现这类问题的根本原因在哪？如何才能避免此类问题的出现呢？ 希望下面的内容能不能解决上述的疑问。</p><p>首先，咱们看看浮点数在计算机里如何表示。先举个栗子，例如，小数(0.125)10，在十进制中其值等于1/10 + 2/100 + 5/1000 的值，这都很容易理解。如果将其转化为二进制小数则为(0.001)2， 是0/2 + 0/4 + 1/8.。的值，有点难懂是吧，可以参考下面的运算过程。 注意，两者在数值上相等，区别为：前者为十进制小数，后者为二进制小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a. 十进制小数 to 二进制小数的方法：<span class="string">"乘2取正, 顺序输出"</span>，即乘<span class="number">2</span>取整，余数继续</span><br><span class="line">乘<span class="number">2</span>取整重复至小数部分为零或达到指定精度，第一次为最高位，最后一次为最低位。</span><br><span class="line">例： 十进制小数(<span class="number">0.125</span>)<span class="number">10</span>的二进制小数算法如下: </span><br><span class="line">    <span class="number">0.125</span> * <span class="number">2</span> = <span class="number">0.25</span>   取整 <span class="number">0</span> 余 <span class="number">0.25</span></span><br><span class="line">    <span class="number">0.25</span> * <span class="number">2</span> = <span class="number">0.5</span>     取整 <span class="number">0</span> 余 <span class="number">0.5</span></span><br><span class="line">    <span class="number">0.5</span> * <span class="number">2</span> = <span class="number">1.0</span>      取整 <span class="number">1</span> 余 <span class="number">0</span></span><br><span class="line">则 (<span class="number">0.001</span>)<span class="number">2</span> 为小数(<span class="number">0.125</span>)<span class="number">10</span>的表达。</span><br><span class="line"></span><br><span class="line">b. 二进制小数 to 十进制小数，小数点后的权位表达方法为 <span class="number">2</span>^(<span class="number">-1</span>), <span class="number">2</span>^(<span class="number">-2</span>),</span><br><span class="line"> <span class="number">2</span>^(<span class="number">-3</span>), ... , <span class="number">2</span>^(-n)。则如果将二进制小数(<span class="number">0.001</span>)<span class="number">2</span>转换为十进制方法如下:</span><br><span class="line">     <span class="number">0</span>/<span class="number">2</span> + <span class="number">0</span>/<span class="number">4</span> + <span class="number">1</span>/<span class="number">8</span> = (<span class="number">0.125</span>)<span class="number">10</span></span><br><span class="line">感兴趣的朋友可以使用下面代码进行尝试。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.125</span></span><br><span class="line"><span class="number">0.125</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">10</span> + <span class="number">2</span>/<span class="number">100</span> + <span class="number">5</span>/<span class="number">1000</span></span><br><span class="line"><span class="number">0.125</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span>/<span class="number">2</span> + <span class="number">0</span>/<span class="number">4</span> + <span class="number">1</span>/<span class="number">8.</span></span><br><span class="line"><span class="number">0.125</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>因为计算机内部的所有运算都是基于二进制的，在计算机内部，大部分的十进制的分数（大部的分数可以通过小数表达）却不能使用二进制完美地表达。这和十进分数1/3十分相似，可以取为0.3，或者精确一些取为0.33，或者再精确点取0.333，进而以此类推，在十进制下，可以无限接近，但是却不能绝对精确。相同的原因，十进制数(0.1)10不能通过一个二进制的小数准确地表达，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">小数(0.1)10 转换为二进制小数，步骤如下：</span><br><span class="line">        0.1 * 2 &#x3D; 0.2 取整 0 余 0.2</span><br><span class="line">        0.2 * 2 &#x3D; 0.4 取整 0 余 0.4</span><br><span class="line">        0.4 * 2 &#x3D; 0.8 取整 0 余 0.8</span><br><span class="line">        0.8 * 2 &#x3D; 1.6 取整 1 余 0.6</span><br><span class="line">        0.6 * 2 &#x3D; 1.2 取整 1 余 0.2 </span><br><span class="line">        ... </span><br><span class="line">然后就开始无限循环了 -_- 。</span><br></pre></td></tr></table></figure><p>所以，在计算机内部，如果用一个二进制小数表达1/10 即 0.1 的时候，二进制的小数大概为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0.00011001100110011001100110011001100110011001100110011010</span>)<span class="number">2</span></span><br></pre></td></tr></table></figure><p>其值非常接近余1/10 但却不相等。一般情况下，我们会需要一个同一的标准，在IEEE 754 双精度浮点标准下，Python会用53位的精度来表达1/10。而此时如果我们将上面的二进制转换为小数应该会得到下面的值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0.1000000000000000055511151231257827021181583404541015625</span>)<span class="number">10</span></span><br></pre></td></tr></table></figure><p>其值非常接近于0.1却不等于0.1。这时候可能就有人会问，我在Python的交互界面下输入0.1时，交互界面打印出来的就是0.1啊，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span></span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.1</span>)</span><br><span class="line">Decimal(<span class="string">'0.1000000000000000055511151231257827021181583404541015625'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>其实这时候，Python的交互命令行只打印了这个值的一小部分，真实值（注意这里的真实值也与实际值1/10不相等）的近似值。如果想查看完整的小数表达，可以使用decimal模块下的Decimal()函数，如上。</p><p>小结一下，<strong>Python确实不认识0.1。</strong>其实应该说，计算机不能准确地用二进制地方法表达0.1。如果能明白这些，就应该知道，<strong>这并不是Python这种语言的Bug</strong>，也不是自己代码的Bug，这是二进制浮点数的常见情况（不能称之为问题）。而且所有的编程语言会出现这种情况，所有支持浮点运算的计算机也都存在相似的情况，只是表现方式会有所差异。</p><p>若不注意这些，在编写代码的时候会出现什么样的潜在问题呢？因为计算机不能正确的表达1/10，显而易见的问题就是我们文章一开头的求和问题。遇见这样的问题时，有人会提出Python和一些编程语言提供round()函数，用于取舍不就会得到最接近的值？那该函数是不是也能够用在此处解决这样的问题呢？我们来做个实验，这个实验和文章开头有点不一样，我们也做0.1的求和，但是不做那么多次的加法，三次足亦，如下：</p><p>第一步，我们用最简单的方法求和，求三个0.1的和，然后和0.3进行比较，发现果然和预期（为真）的不一样。要注意：计算机不能正确表达0.1，同时0.3不能被正确表达。所以两者不相等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span> == <span class="number">0.3</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>第二步，我们用round()函数进行提前取舍，取舍精度都为1， 然后进行求和判断。发现结果也不符合预期，可以推测的是，先取舍再求和，最终结果也不和0.3相等。需要注意的是，这个过程不能验证，只要验证了结果就是对的，有点量子论里测不准的感觉，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.1</span>, <span class="number">1</span>) + round(<span class="number">0.1</span>, <span class="number">1</span>) + round(<span class="number">0.1</span>, <span class="number">1</span>) == round(<span class="number">0.3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>第三步， 我们不提前取舍，先求和然后取舍，进而与0.3 进行比较，此时结果就符合预期了，而且调整取舍精度也能再次得到预期的结果，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>, <span class="number">1</span>) == round(<span class="number">0.3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.1</span> + <span class="number">0.1</span> + <span class="number">0.1</span>, <span class="number">10</span>) == round(<span class="number">0.3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>上面的例子中不仅仅是因为，计算机里二进制浮点数不能正确表达十进制分数的；还有一个原因是内置round()函数的取舍也有问题。例如，一个小数2.675舍入到小数点后两位，按照四舍五入的原则，预期的结果应该为2.68。但是实际不是，是2.67，原因就是计算机浮点数不能正确表达十进制分数（小数）。十进制小数2.675的在计算机内转换为浮点数后如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.67499999999999982236431605997495353221893310546875</span></span><br></pre></td></tr></table></figure><p>因为，这个数的数值更接近与2.67而不是2.68，所以使用round()函数时会向下取舍。</p><p>小结，因为计算机的二进制浮点数不能正确表达十进制分数，所以编程时遇见浮点数据运算就会得到诸如此类的奇异结果。但我们不能因为会遇见这样的怪异现象，就仇视或者惧怕浮点数和有意避免浮点数运算。此问题有种官方的叫法，叫做<strong>表达错误</strong>（representation error）。</p><h2 id="表达错误"><a href="#表达错误" class="headerlink" title="表达错误"></a><strong>表达错误</strong></h2><p>在这个章节中我们探索一下，十进制的分（小）数在计算机里是如何转换为二进制的浮点数的。也希望借助此章节的内容，各位能够更加深入地理解为什么编程语言不能按照预期表达十进制数值。</p><p>通过前面的章节我们已经确定，计算机确实不能正确地表达1/10，而如今绝大部分的计算机都使用IEEE-754的浮点数算法，而几乎所有的平台和版本的Python会将浮点数映射为IEEE-754的双精度浮点数。即，计算机会尽量将输入的十进制小数通过方程J/2^N转化为最接近的二进制小数，其中J为一个53位的整数，N为最佳指数。</p><p>举例来说，就拿1/10来说，如果该有理数需要在Python中需要转化为计算机的双精度浮点数，通过上面的方程来转化会写作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">10</span> ≈ J/<span class="number">2</span>^N <span class="comment">#近似等于</span></span><br></pre></td></tr></table></figure><p>转换等式，可得：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">J ≈ <span class="number">2</span>^N / <span class="number">10</span></span><br></pre></td></tr></table></figure><p>因为双精度浮点数有52位来存储有效数字，而同时IEEE 754规定：在计算机内部保存有效数字时，默认这个小数（二进制）的第一位总是1，因此可以被舍去，只保存后面的内容。因此双精度浮点的有效数数字应该有53位。即在上式中J应该被定义为一个53位的整数。等式的右边应该无限接近于这个53位的整数即，应该满足大于等于2^52，小于2^53。通过计算可得当N等于56时满足条件，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">52</span></span><br><span class="line"><span class="number">4503599627370496L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">56</span> // <span class="number">10</span></span><br><span class="line"><span class="number">7205759403792793L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">53</span></span><br><span class="line"><span class="number">9007199254740992L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">52</span> &lt;=  <span class="number">2</span>**<span class="number">56</span> // <span class="number">10</span>  &lt; <span class="number">2</span>**<span class="number">53</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>接下来我们就要考虑这个等于2^56的整数是不是位最佳值，为此，需要得到该整数与10进行除法运算的商和余数，在这可以使用divmod()内置函数，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q, r = divmod(<span class="number">2</span>**<span class="number">56</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q, r</span><br><span class="line">(<span class="number">7205759403792793L</span>, <span class="number">6L</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>在上式中其除法运算的余数大于5，即更接近10，所以该整数的最佳近似值，应该向上取整，即在原来商的基础上加1。</p><p>因此，十进制的分数1/10，在IEEE 754 规定的双精度浮点的标准下，最佳近似值如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">7205759403792794</span> / <span class="number">2</span> ** <span class="number">56</span></span><br><span class="line"><span class="number">0.1</span></span><br></pre></td></tr></table></figure><p>由于我们在计算的时，整数J向上取整了（式子为J/2^N)，也就意味着得到的浮点数应该比1/10要稍微大一点。而如果我们不向上取整，又会比1/10的实际值小一点点。反正不管怎么算，就是得能精确等于1/10，这就是为什么说Python从没见过1/10长什么样，即计算机其实不认识1/10。</p><p>我们再往下探索一下：由上可知，按照IEEE 754 标准，如果我们将最后一步中分子分母约分（因为分子为偶数，即公因数为2），则可以得到下面的内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3602879701896397</span> / <span class="number">2</span> ** <span class="number">55</span></span><br></pre></td></tr></table></figure><p>这时候，J为3602879701896397，N为55。如果我们想看到这个浮点数所有的有效数字，可以将小数整数化，也就是说让J乘以10^55，就可以得到一个55位的整数，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3602879701896397</span> * <span class="number">10</span> ** <span class="number">55</span> // <span class="number">2</span> ** <span class="number">55</span></span><br><span class="line"><span class="number">1000000000000000055511151231257827021181583404541015625L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Decimal(<span class="number">0.1</span>)</span><br><span class="line">Decimal(<span class="string">'0.1000000000000000055511151231257827021181583404541015625'</span>)</span><br></pre></td></tr></table></figure><p>由上可得，得到的整数化的有效数字，和计算机内部存储的是相同的。也就证明了，整个推到过程是正确无误的。虽然计算机可以实现到53位的精度。但是因为编程语言中print足够聪明，所以如果直接输入0.1，打印出来的内容也就是0.1。因为大部分情况下，可能不需要这个高的精度，所以很多编程语言在做浮点数的算术运算的时候，一般取的是小数点后17位的精度，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.1</span></span><br><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%.17f"</span> % <span class="number">0.1</span></span><br><span class="line"><span class="number">0.10000000000000001</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>因为运算的每一步都需要会涉及到精确度和有效数字丢失的问题，所以编程中，浮点数的计算常常会得到不满足预期的结果，但是浮点数又是很重要的一种数据类型，又不能够舍弃。总之，当遇见代码中出现浮点算术运算问题的时候，就应该考虑到是不是遇见了上面的问题，进而就要找到合适的计算方式，对计算结果进行精度上的取舍。而如果代码中设计到大量的浮点数计算，在Python中，就可以考虑使用专门的模块来处理这些计算。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a><strong>讨论</strong></h2><p>Python 的浮点数运算模块decimal，使用decimal中的Decimal函数可以允许浮点数以字符串的方式传入，这样就可以保有足够的（大于双精度浮点数的53位）有效数字，从而避免计算时精度的丢失。在本章的一开始遇见的0.1求和的问题就可以使用Decimal来解决，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = Decimal(<span class="string">'0.0'</span>) <span class="comment"># 注意：传入字符串。若传入浮点数，就丢失了精度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    x += Decimal(<span class="string">'0.1'</span>) </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">Decimal(<span class="string">'1.0'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%.17f"</span> % x1<span class="number">.00000000000000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(x) == <span class="number">1</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>Decimal模块可以解决问题，在一些涉及到高精度计算或者一些金融方面的计算时，也能够保证不丢失精度，毕竟关乎钱的问题就不能允许有误差存在，但是这样的计算会却有牵扯到浮点数与字符串之间的转换问题，性能肯定会下降。程序设计是需要考虑到所有因素，假如17位的普通精度能够满足设计要求，而且计算允许一定的误差，同时又有性能上的要求，毕竟原生的浮点数计算速度会快很多，就可以使用math模块来解决类似的问题。</p><p>关于math模块我们在这里借助一个新的例子，这个例子更为典型也十分有趣，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1.23e+18</span>, <span class="number">1</span>, <span class="number">-1.23e+18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(nums)</span><br><span class="line"><span class="number">0.0</span></span><br></pre></td></tr></table></figure><p>求和过程丢失了一个1，感觉十分神奇。其计算结果就不是近似了，根本就是完全错误。主要原因就是函数sum()做的就是一个加法运算，该函数不在意过程中精度的损失，只是简单的求和。为了避免上面的计算错误，就可以使用math模块下的fsum()函数来处理，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1.23e+18</span>, <span class="number">1</span>, <span class="number">-1.23e+18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.fsum(nums)</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>使用函数math.fsum()进行计算的时候，函数会回溯每一步计算的误差，在保持精度的同时得到计算的最优解，所以结果符合预期。总的来说，decimal模块可以被用于涉及到金融领域和科学计算的工程领域。但是一般问题中设计到浮点数计算的问题，math模块足够胜任。</p><p>在程序开发上遇到问题，如果追本溯源，就肯定能够找到问题的根本原因，也能够借助一篇篇文章了解问题出现的机理，进而明白一些现实因素的局限性，也能够扩展自己知识面，也希望大家能够通过这篇文章真正理解，为什么计算机不能正确认识1/10，即明白二进制下如何表达浮点数的方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p>IEEE754 的内容 ：<a href="https://de.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">https://de.wikipedia.org/wiki/IEEE_754</a></p><p>Python表达错误 ：<a href="https://docs.python.org/2/tutorial/floatingpoint.html" target="_blank" rel="noopener">https://docs.python.org/2/tutorial/floatingpoint.html</a></p><p>Python浮点计算 ：<a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p02_accurate_decimal_calculations.html" target="_blank" rel="noopener">http://python3-cookbook.readthedocs.io/zh_CN/latest/c03/p02_accurate_decimal_calculations.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 8. Python 杂记" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-8-Python-%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
      <category term="浮点数" scheme="http://yoursite.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python 应用之 Two sum</title>
    <link href="http://yoursite.com/2018/11/23/0701-issue-twosum/"/>
    <id>http://yoursite.com/2018/11/23/0701-issue-twosum/</id>
    <published>2018-11-23T00:11:08.000Z</published>
    <updated>2018-11-23T00:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><p>最近一直考虑着下一篇关于Python的文章应该是什么样的内容，对比一些专业大咖的文章，目前应该写一个完整的且无错的程序，然后和大家一起一行行地分析代码相互学习，可是我实在不想如此亦步亦趋。在学习编程方面，我是一个实用主义者，认为“学以致用”才是学习的最终目的， 最近发现了一些有趣的东西，让我很感兴趣，也能检验我自己所学的东西。</p><p>本着“学以致用”为先，从今天开始我们通过研究算法的方式，进而明白自己之前学的内容如何更好地使用。之所以打算写这样方面的内容，也是因为最近的一次和猎头通话时，被问到类似的问题，可是自己竟然不会，丢脸啊。所以就下定决心研究算法，在此把自己所学所想跟大家分享。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h2><p>* 英文原文：</p><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice.</p></blockquote><p>* 我的理解：</p><blockquote><p>给定一个整数数组和一个目标值，求数组内两个元素和为目标值的指针。 需要保证每次输入都能得到正确的解，并且任何一个元素<strong>不能</strong>使用两次。</p></blockquote><p>* 例：</p><blockquote><p>如有列表 [2, 7, 11, 15] 若目标值 9， 因为 2 + 7 = 9， 所以得[0, 1]; 若目标值 18， 因为 7 + 11 = 18， 所以得[1, 2]。</p></blockquote><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a><strong>解决思路</strong></h2><ul><li><strong>第一步推导</strong></li></ul><p>使用最简单的思路暴力解决。 历遍列表中的每一个元素，然后检查是否相邻的两个元素的和是否和所求一致，如果相同则返回这两个元素的索引。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Approach1</span><span class="params">(listInput, iTarget)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Brute Force</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type listInput: List[int]</span></span><br><span class="line"><span class="string">        :type iTarget: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(listInput) &lt;= <span class="number">1</span>:            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> iDx <span class="keyword">in</span> range(len(listInput)):            </span><br><span class="line">            <span class="keyword">for</span> jDx <span class="keyword">in</span> range(<span class="number">1</span>, len(listInput)):                </span><br><span class="line">                <span class="keyword">if</span> listInput[jDx] == (iTarget - listInput[iDx]):</span><br><span class="line">                    <span class="keyword">return</span> [iDx, jDx]</span><br></pre></td></tr></table></figure><p>这样的方法虽然不能符合题目要求，因为列表中的每一个元素都被使用了两次。但是可以以此为基础，进一步探索找到解决问题的最优解。</p><ul><li><p><strong>第二步推导</strong></p><p>因为第一步推导中方法的时间复杂度为O(n^2)。 为了优化时间复杂度，就要尝试找到一个更加高性能的方法来检查一个元素与目标值的差是否存在于列表中。 而且当其差值存在，我们还要得到该元素的索引。 那么最好的保存两者映射的途径是什么？ 当然是一个哈希表，在Python中为字典。</p></li></ul><p>为了提高效率就要减少查找时间，准确地说把两者映射的查找次数从N降低到1。 而哈希表就是为此而生的。 理论上使用哈希表可以实现在恒定时间内完成查找。但是现实中可能会出现哈希函数不完善造成的冲突可能会导致查找次数重新从1退到n。 所以选择合适的哈希函数也是很重要的。 以此为思路优化第一步的推导，就得到下面的代码。 Python作为高级编程的语言，虽然解释器封装了哈希函数，也会存在碰撞冲突的风险，但一般很少出现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Approach2</span><span class="params">(listInput, iTarget)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Two-pass Hash Table</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type listInput: List[int]</span></span><br><span class="line"><span class="string">        :type iTarget: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(listInput) &lt;= <span class="number">1</span>:            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># dictBuffer = &#123;&#125;</span></span><br><span class="line">        <span class="comment"># for iDx in range(len(listInput)):</span></span><br><span class="line">        <span class="comment">#    dictBuffer[listInput[iDx]] = iDx</span></span><br><span class="line">        dictBuffer = dict(zip(listInput, range(len(listInput))))        </span><br><span class="line">        <span class="keyword">for</span> iDx <span class="keyword">in</span> range(len(listInput)):</span><br><span class="line">            iComplement = iTarget - listInput[iDx]            </span><br><span class="line">            <span class="keyword">if</span> dictBuffer.has_key(iComplement) <span class="keyword">and</span> dictBuffer.get(iComplement) != iDx:</span><br><span class="line">                <span class="keyword">return</span> [iDx, dictBuffer.get(iComplement)]</span><br></pre></td></tr></table></figure><p>上述的推导里面，使用了两个迭代，第一次迭代中（被注释的内容），循环将每个元素和其索引添加到字典内。然后在第二个迭代中，我们检查字典中是否存在其中一个元素差值为键的映射，如果存在就返回该元素以及差值对于的索引。 需要检验该差值不能为元素本身。</p><ul><li><strong>第三步推导</strong></li></ul><p>通过正确理解第二步推导，其实可以发现。 相同的目的也可以通过一次迭代完成。 在迭代的过程中，我们先判断当前元素是否存在于映射字典中，该映射字典保存了列表中一个元素与目标值的差以及该元素的索引。如果存在就立即返回。 若不存在，则将该元素与目标值的差作为键，其索引作为值，保存在这个映射字典中。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Approach3</span><span class="params">(listInput, iTarget)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        One-pass Hash Table</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :type listInput: List[int]</span></span><br><span class="line"><span class="string">        :type iTarget: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(listInput) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dictBuffer = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> iDx <span class="keyword">in</span> range(len(listInput)):</span><br><span class="line">            <span class="keyword">if</span> listInput[iDx] <span class="keyword">in</span> dictBuffer:</span><br><span class="line">                <span class="keyword">return</span> [dictBuffer[listInput[iDx]], iDx]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dictBuffer[iTarget - listInput[iDx]] = iDx</span><br></pre></td></tr></table></figure><p>可以看出第三步的推导能够满足题目的要求，即每个元素只能使用一次，而且解决方案的时间复杂度(O(n))和空间复杂度(O(n))都为最优。 关于算法的复杂度，即时间复杂度和空间复杂度的内容，我找机会总结后分享给大家。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>第三步推导完成之后，真的是醍醐灌顶。通过这三步推导，从最早的暴力解决，一步步地靠近正确的答案，发现这里面没有新的编程技术，也没有自创的数据类型。全都是之前文章介绍过的基本知识，可是通过改变这些基本内容的使用方法和方式，就能得到不一样的效果。也意识到，我们都有解决问题的能力和想到解决方案的智慧，只是很多时候面对问题时，都是以简单和快速为先，并没有考虑使用的方法是否最优。很多时候只要具有就是看下去的毅力和试下去的恒心，我们都能找到解决问题的最优解。</p><p>研究这个算法的过程，也认识到自己离软件大拿和行业翘楚还很远。也明白自己看待问题的眼光，解决问题的思路包括编程的思维都是有局限。这篇文章也作为我自己对待编程的新起点，希望与君相互讨论帮助，共同进步学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 7. Python 应用" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-7-Python-%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 循环语句for</title>
    <link href="http://yoursite.com/2018/11/21/030302-for/"/>
    <id>http://yoursite.com/2018/11/21/030302-for/</id>
    <published>2018-11-21T00:11:08.000Z</published>
    <updated>2018-11-21T00:11:08.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Python 相关 - 3. 基本语法" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
      <category term="运算符" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 条件语句if-elif-else</title>
    <link href="http://yoursite.com/2018/11/20/030301-if-elsif-else/"/>
    <id>http://yoursite.com/2018/11/20/030301-if-elsif-else/</id>
    <published>2018-11-20T14:11:08.000Z</published>
    <updated>2018-11-20T14:11:08.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Python 相关 - 3. 基本语法" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
      <category term="运算符" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 运算符</title>
    <link href="http://yoursite.com/2018/11/20/030201-operator/"/>
    <id>http://yoursite.com/2018/11/20/030201-operator/</id>
    <published>2018-11-20T07:11:08.000Z</published>
    <updated>2018-11-20T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="Python运算符简介"><a href="#Python运算符简介" class="headerlink" title="Python运算符简介"></a>Python运算符简介</h2><p>程序语言运算符就是对数据操作的表示方法，即数据是如何处理的。理解运算符，在查看代码的时候就能理解代码中数据是如何加工处理的，掌握运算符就能过对数据按照自己所想操作加工处理。一般的教程或者学习资料会将操作符分为：算术运算符、连接运算符、关系运算符、赋值运算符和逻辑运算符。这也是普遍的共识。在本文中，我们稍作改变，我们分组分章节介绍，之所以这样，也是一些运算符好之间也有一定的关系。Python中有一种比较特殊的运算符，即身份运算，会单独介绍一下。位运算从本质上来讲也属于算术表达的一种，但是由于其比较特殊，常在硬件设计方面应用较多，日常的应用设计很少遇到，所以在文中也用单独的章节介绍。</p><h2 id="算术运算符与赋值运算符"><a href="#算术运算符与赋值运算符" class="headerlink" title="算术运算符与赋值运算符"></a>算术运算符与赋值运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术计算，在此是指常见的十进制计算，包括加法➕，减法➖，乘法✖️，除法➗，都是常见的数学计算，除了表现符号与数学课本上不一致，如，Python乘法（_），除法（/）。任何人理解这些符号的意义，在这里就不在赘述。在此我们仅介绍<strong>取模</strong>，<strong>取整</strong>， 和*幂运算(包括逆运算，即对数运算)_，Python中也有math或cmath模块，提供专门的函数来帮助你进行更复杂的算术运算，如有需要可以关注一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">c = a  // b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取整 c 的值为："</span>, c</span><br><span class="line"></span><br><span class="line">c = a % b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取模 c 的值为："</span>, c </span><br><span class="line"></span><br><span class="line">c = a ** b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"幂运算 c 的值为："</span>, c </span><br><span class="line"></span><br><span class="line">d = c ** (<span class="number">1.</span>/b)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"幂的逆运算 d 的值为："</span>, d</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取整 c 的值为： 3</span><br><span class="line">取模 c 的值为： 1</span><br><span class="line">幂运算 c 的值为： 49</span><br><span class="line">幂的逆运算 d 的值为： 7.0</span><br></pre></td></tr></table></figure><p>取整就是得到除法的结果的整数部分，取模就是得到除法的结果的余数（<strong>切记并非小数部分</strong>），幂运算可以处理平方，三次方等，幂运算符也可以处理幂运算的逆运算，即对数运算。上面代码1后面的那个点<strong>.</strong>就表示1要按照浮点数进行运算操作。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算就是将算数运算结果赋值于变量，符号为<strong>=</strong>。 算术运算符➕与赋值的组合能过更简化代码，也就是常说的变量自加。即算术运算过程中等号左边的变量也作为算术运算的参与者，简单举个例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">7</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a + b</span></span><br><span class="line">a += b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"加法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a - b</span></span><br><span class="line">a -= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"加法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a * b</span></span><br><span class="line">a *= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"乘法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a * b</span></span><br><span class="line">a *= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"乘法与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a ** b</span></span><br><span class="line">a **= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"幂与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a // b</span></span><br><span class="line">a //= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取整与赋值的值为：%s"</span> % a</span><br><span class="line"><span class="comment"># a % b</span></span><br><span class="line">a %= b</span><br><span class="line"><span class="keyword">print</span> <span class="string">"取模与赋值的值为：%s"</span> % a</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">加法与赋值的值为：10</span><br><span class="line">加法与赋值的值为：7</span><br><span class="line">乘法与赋值的值为：21</span><br><span class="line">乘法与赋值的值为：63</span><br><span class="line">幂与赋值的值为：250047</span><br><span class="line">取整与赋值的值为：83349</span><br><span class="line">取模与赋值的值为：0</span><br></pre></td></tr></table></figure><p>由于变量a参与了算术计算，所以变量a的值一直发生了变化，所以不要怀疑结果出了问题。</p><h2 id="比较运算符，成员运算符，身份运算符"><a href="#比较运算符，成员运算符，身份运算符" class="headerlink" title="比较运算符，成员运算符，身份运算符"></a>比较运算符，成员运算符，身份运算符</h2><p>这个章节的运算符，在编程中主要用于与条件语句进行配合，并返回True 与 Flase布尔值的运算符。</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符比较容易理解：等于==， 不等于!=或者&lt;&gt;, 大于&gt;与大于且等于&gt;=和小于&lt;与小于且等于&lt;= 。关于这些也就不再举例，需要注意的是比较的两个元素应该具有相同的数据类型，或者都是类的实例。</p><h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>成员运算符是用于检查某一值是否在可迭代的对象里面，返回值True或False。</p><p>可迭代的对象Iterable并不等于迭代器Iterator。Python中这两种定义有部分相同，但是还是有一些细节的差异的。为了便于区分，这里给你一个简单的方法来区别彼此，能用for进行循环迭代的都成为可迭代对象，能被next()调用不断返回下一个值的对象为迭代器。有关两者更细节话的区别，我们在以后的文章中介绍。</p><p>可迭代的对象是一种集合数据类型，如list，tuple，dict，set与str等。成员运算符为”in”和”not in”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">21</span></span><br><span class="line">c = <span class="string">"a"</span></span><br><span class="line">d = <span class="number">1</span></span><br><span class="line">lt = [<span class="number">11</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">tup = (<span class="number">11</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">ss = set([<span class="number">11</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">dic = &#123; <span class="string">"a"</span> : <span class="number">2</span>, <span class="string">"b"</span> : <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">in</span> lt:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 在给定的列表中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 不在给定的列表中"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">not</span> <span class="keyword">in</span> lt:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 不在给定的tuple 中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 在给定的tuple中"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">not</span> <span class="keyword">in</span> ss:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 不在给定的set 中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 b 在给定的set 中"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">in</span> dic:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 c 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 c 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> d <span class="keyword">in</span> dic:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 d 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 d 不在给定的dict中"</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量 a 在给定的列表中</span><br><span class="line">变量 b 不在给定的tuple 中</span><br><span class="line">变量 b 不在给定的set 中</span><br><span class="line">变量 c 在给定的dict中</span><br><span class="line">变量 d 不在给定的dict中</span><br></pre></td></tr></table></figure><p>需要注意的是，在Python 2.x中，成员运算符与dict结合使用的时候等效于has_key()函数，即用于检查是否字典dict变量存在某一键。但是Python 3.x不再具有该函数，所以只能用成员运算符。为了保证代码的兼容性和一致性，建议优先选用成员运算符来判断某一键存在与字典之中。在此我们也做个延伸，请看下方例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">e = &#123;<span class="string">"a"</span> : <span class="number">1</span>, <span class="string">"b"</span> : <span class="number">2</span>, <span class="string">"c"</span> : <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">akeys = e.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> e:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> akeys:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> e[<span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> e:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">"a"</span> <span class="keyword">in</span> akeys:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 在给定的dict中"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"变量 'a' 不在给定的dict中"</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 不在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 不在给定的dict中</span><br><span class="line">变量 &#39;a&#39; 在给定的dict中</span><br></pre></td></tr></table></figure><p>有人可能会想，我在代码中某一处获取一个字典的所有键的列表，然后在以后需要判断的时候，直接使用这个键的列表来判断，这种想法是很危险的，也是不可取的。请参照上述例子。字典键的判断最好是按需实时进行，以避免误判。</p><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于比较两个对象的储存单元。也就是判断两个引用的对象是否为同一个，即两个在储存意义上的一致。需要注意的是，Python程序中，<strong>值相同并不意味着”一致”，”一致”必然值相同</strong>。</p><ul><li><strong>is</strong> ，判断是否一致，是否引用自同一个对象 。 <strong>a is b</strong> 等效于 id(a) == id(b), id() 函数用于获取内存地址，地址一致则为同一个对象 。</li><li><strong>not is</strong>， 与<strong>not</strong> 结合，意指取上述内容反义。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 没有相同的标识，不一致"</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">is</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"a 和 b 没有相同的标识，不一致"</span></span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = c </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">is</span> d :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 没有相同的标识，不一致"</span></span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = c[:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">is</span> d :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 有相同的标识，一致"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"c 和 d 没有相同的标识，不一致"</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a 和 b 有相同的标识，一致</span><br><span class="line">a 和 b 有相同的标识，一致</span><br><span class="line">c 和 d 有相同的标识，一致</span><br><span class="line">c 和 d 没有相同的标识，不一致</span><br></pre></td></tr></table></figure><p>从上述输出结果可以得知，整数（也包含浮点数）的变量，在值相同的情况下，赋值或者从新赋值，其引用的是同一块内存，列表在赋值的时候，上文中，从c赋值到d的时候也是引用的同一块内存。但是如果需要保证列表c和d在使用时相互之间不影响，就要对d进行重新赋值。这些都是需要在编写代码时候考虑的，从而避免不必要的错误。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符常在条件语句和while循环语句中与上述的比较运算符，成员运算符与身份运算符结合使用。用于结合两个条件，或者否定某一条件。但是需要注意的是，其他语言中的逻辑运算符并不在Python语言中兼容，在程序代码转换时候需要注意。</p><table><thead><tr><th align="center">逻辑运算符（其他语言）</th><th align="center">逻辑运算符（Python）</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">and</td></tr><tr><td align="center">||</td><td align="center">or</td></tr><tr><td align="center">！</td><td align="center">not</td></tr></tbody></table><p>代码实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">True</span></span><br><span class="line">b = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>  a <span class="keyword">and</span> b :  <span class="comment"># 等效其他语言的 &amp;&amp;</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 有一个不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b : <span class="comment"># 等效其他语言的 ||</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true，或其中一个变量为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span>  a <span class="keyword">and</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 有一个不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b :</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true，或其中一个变量为 true"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都不为 true"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>( a <span class="keyword">and</span> b ): <span class="comment"># 等效其他语言的 ！</span></span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 false，或其中一个变量为 false"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"变量 a 和 b 都为 true"</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量 a 和 b 都为 true</span><br><span class="line">变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line">变量 a 和 b 有一个不为 true</span><br><span class="line">变量 a 和 b 都为 true，或其中一个变量为 true</span><br><span class="line">变量 a 和 b 都为 false，或其中一个变量为 false</span><br></pre></td></tr></table></figure><p>以上介绍的都是常用的运算符，在日常程序设计实现时常常用到，对比其他编程语言Python有一下独有的运算符，或一些运算符在Python中的表现形式会有一些不同，都需要在实现代码时注意。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符，会在硬件编程中用到，主要处理二进制的计算。在日常任务中并不常见，但是它也是学习进而掌握一种编程语言的必备知识。在我经历的任务中，比如需要得到RGB颜色的整数或者16进制数。RGB整数与RBG三色值之间的相互转换时，用到过位运算符。Python的位运算符与其他语言的位运算符一致，在本节我们介绍一下位运算符。</p><ul><li><strong>&amp;</strong>， 二进制的”<strong>与</strong>“操作。二进制相应位都位1，则结果为1，反之为0。</li><li><strong>|</strong>， 二进制的”<strong>或</strong>“操作。结合逻辑运算符来理解，二进制相应位有一个位1时，结果就为1，反之为0。</li><li><strong>^</strong>，二进制的”<strong>异或</strong>“操作。二进制相应位不同时，结果为1，反之为0。</li><li><strong>~</strong>， 二进制的”**取反”操作。二进制数按位取反，1变为0，0变为1。</li><li><strong>&lt;&lt;</strong>，二进制的”<strong>左移</strong>“操作。由符号”&lt;&lt;”右边的数字决定向左移动的位数，高位丢弃，低位补0。</li><li><strong>&gt;&gt;</strong>，二进制的”<strong>右移</strong>“操作。由符号”&gt;&gt;”右边的数字决定向左移动的位数，高位补0。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">50</span>           <span class="comment"># 50 = 0011 0010 </span></span><br><span class="line">b = <span class="number">14</span>           <span class="comment"># 14 = 0000 1110</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">c = a &amp; b;        <span class="comment"># 2 = 0000 0010</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a | b;        <span class="comment"># 62 = 0011 1110 </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a ^ b;        <span class="comment"># 60 = 0011 1100</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = ~a;           <span class="comment"># -51 = -0011 0011</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;       <span class="comment"># 200 = 1100 1000</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br><span class="line"></span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;       <span class="comment"># 12 = 0000 1100</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为dec："</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">"c 的值为bin：&#123;:#010b&#125;"</span>.format(c)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c 的值为dec： 2</span><br><span class="line">c 的值为bin：0b00000010</span><br><span class="line">c 的值为dec： 62</span><br><span class="line">c 的值为bin：0b00111110</span><br><span class="line">c 的值为dec： 60</span><br><span class="line">c 的值为bin：0b00111100</span><br><span class="line">c 的值为dec： -51</span><br><span class="line">c 的值为bin：-0b0110011</span><br><span class="line">c 的值为dec： 200</span><br><span class="line">c 的值为bin：0b11001000</span><br><span class="line">c 的值为dec： 12</span><br><span class="line">c 的值为bin：0b00001100</span><br></pre></td></tr></table></figure><p>可使用bin()内置函数来获取而数的二进制字符串，但是如果要更好的格式化字符串，即带有前补零和”0b”标示的二进制字符串时，则可使用{:#010b}”.format(value)来实现。</p><h2 id="运算符之间的优先级"><a href="#运算符之间的优先级" class="headerlink" title="运算符之间的优先级"></a>运算符之间的优先级</h2><p>尽然编程语言中的运算符种类如此之多，在相互之间结合使用的时候，哪个操作符会被先执行，这就是操作符之间的优先级问题。在此准备一表单，运算符优先级以数字形式表示，数值越小则表示优先级越高，即在运行时会被优先执行。</p><table><thead><tr><th align="center">优先级</th><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">**</td><td align="left">指数运算，最高优先级</td></tr><tr><td align="center">2</td><td align="left">~ + -</td><td align="left">位的取反操作，一元加号与减号（标示数的正负）</td></tr><tr><td align="center">3</td><td align="left">* / % //</td><td align="left">乘，除，取模和取整</td></tr><tr><td align="center">4</td><td align="left">+ -</td><td align="left">加法，减法</td></tr><tr><td align="center">5</td><td align="left">&gt;&gt;,  &lt;&lt;</td><td align="left">位操作左移，位操作右移</td></tr><tr><td align="center">6</td><td align="left">&amp;</td><td align="left">位操作 与</td></tr><tr><td align="center">7</td><td align="left">^ ,  |</td><td align="left">位操作 异或 与 或</td></tr><tr><td align="center">8</td><td align="left">&lt;=, &lt;&gt;, &gt;=</td><td align="left">比较运算符</td></tr><tr><td align="center">9</td><td align="left">&lt;&gt;, ==, !=</td><td align="left">等于，不等于运算符</td></tr><tr><td align="center">10</td><td align="left">=, %=, /=, -=, +=, <em>=, *</em>=</td><td align="left">赋值运算符，自加，自减等</td></tr><tr><td align="center">11</td><td align="left">is, is not</td><td align="left">身份运算符</td></tr><tr><td align="center">12</td><td align="left">in, not in</td><td align="left">成员运算符</td></tr><tr><td align="center">13</td><td align="left">not, and, or</td><td align="left">逻辑运算符</td></tr></tbody></table><p>传统数学计算时的优先级也在上述列表中得到体现，如，乘除法运算优先与加减法运算。括号可以提升优先级。操作符的优先级结合数学计算的优先级，又加上了编程语言的特有预算符的优先级。掌握运算符的优先级，没有什么技巧，只有在不断的实践中加深印象，从而实现熟练使用。</p><h2 id="运算符扩展—-函数注释-Function-Annotations"><a href="#运算符扩展—-函数注释-Function-Annotations" class="headerlink" title="运算符扩展— 函数注释 Function Annotations"></a>运算符扩展— 函数注释 Function Annotations</h2><p>Python 3.x 增加了一个新的特性Feature，叫做<strong>函数注释Function Annotations</strong>。其表现特征是函数定义是，在函数定义括号内使用”:”来注释参数，在右括号外添加”-&gt;”符号，来注释返回值。</p><p>我们来举个例子，传统意义上定义函数为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>添加注释的函数可以用如下形式表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a: <span class="string">'spam'</span>, b: <span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span>, c: float)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>参数后的注释，即”:”后的内容可以是任何形式，返回值的注释需要注意返回值的数据类型必须为Python的数据类型。</p><p>函数的注视添加之后会以属性的形式保存在函数中。查看函数注释可以使用如下语句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__annotations__</span><br><span class="line">&#123;'c': &lt;class 'float'&gt;, 'a': 'spam', 'b': (1, 10), 'return': &lt;class 'int'&gt;&#125;</span><br></pre></td></tr></table></figure><p>函数注释只是一种附加的特征，其并不影响函数的传统方式的使用。参数的注释只是一种帮助信息，并没有现实意义上的约束力。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>编程语言的运算符，是学习编程语言的基础。熟练掌握才能进行其他方面知识的学习。目前网络中存在很多Python的教程，本人也无意重复别人做过的事情，只是将自己在学习这门编程语言的时的一些感悟，也对某一部分内容的个人见解与内容的延伸以文字的方式记录下来，这样在查看别的文章的时候，如果遇到一些基本知识的内容，就可以在不跳转别的教程网站的情况下，解决学习中遇到的问题，方便读者也方便自己。欢迎订阅我的个人微信公众号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 3. 基本语法" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
      <category term="运算符" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Python 变量之字典与应用技巧</title>
    <link href="http://yoursite.com/2018/11/19/030104-variable-dict-tips/"/>
    <id>http://yoursite.com/2018/11/19/030104-variable-dict-tips/</id>
    <published>2018-11-19T07:11:08.000Z</published>
    <updated>2018-11-19T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h2 id="Python-标准数据类型"><a href="#Python-标准数据类型" class="headerlink" title="Python 标准数据类型"></a><strong>Python 标准数据类型</strong></h2><p>大家好，最近更新比较慢，临近圣诞节和新年，公司的事情也就异常多。连续几天的会议，还要加紧修复bug，为新版本软件的发布做准备。好了言归正传，书接上回。Python 定义了一些标准数据类型，用于存储各种类型的数据。Python有五个标准的数据类型，分别是：</p><ul><li><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul></li></ul><p>字典在Python中应该算是最后一个重要的基本变量，出现在代码中的频率也比较高。常被用作为一种可变的数据容器。今天就给大家介绍一下Python最后一个标准数据类型字典，即Dictionary的一些基础知识和在实际应用中的使用技巧。</p><h2 id="Dictionary-字典的特征"><a href="#Dictionary-字典的特征" class="headerlink" title="Dictionary 字典的特征"></a><strong>Dictionary 字典的特征</strong></h2><p>作为一种可变容器模型，那么字典Dict在声明之后就能够任意被修改，比如添加，删除，或者更改。既然名为字典也就意味着其查询索引方式类如真实意义上的字典。Python的自己由一组<strong>键（key）与值（value）</strong>组成。两者之间用冒号隔开（<strong>：</strong>）。组与组之间与逗号（，）隔开。最后用花括号(大括号) “<strong>{}</strong>“ 包裹所有的键值组，就得到一个字典实例，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">di = &#123;key_1 : value_1, key_2 : value_2, key_3: value_3&#125;</span><br></pre></td></tr></table></figure><p>字典中，每一组键值，其键需要有唯一性，但是其值则不需要。在Python中，字典键值的唯一性就限制了它的数据类型选择范围。结合前面文章所介绍的的标准数据类型，除<strong>列表</strong>以外：数值型，元组，字符串都能够作为字典类型的<strong>键</strong>，经过实践可以告诉大家，任何类的实例都可以作为字典的键。因为类一旦实例化，其类实例在内存中的地址具有唯一性，因此也可以作为字典的键，参考下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">pass</span>...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, a:<span class="string">"Object"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span>&gt;: <span class="string">'Object'</span>, <span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">[&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span>&gt;, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&gt;&gt; d.keys()[<span class="number">0</span>]</span><br><span class="line">&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span></span><br><span class="line">&gt;&gt;&gt;&gt; d.keys()[<span class="number">0</span>].isB = <span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()[<span class="number">0</span>]</span><br><span class="line">&lt;__main__.A instance at <span class="number">0x0000000004D2A188</span>&gt;</span><br></pre></td></tr></table></figure><p>字典中，每组键值中的值，没有限定，可以是任意的数据类型。1. 键值是否可变，字典并不做约束，仅仅与数据类型本身有关。如下面代码的例子中，元组可以作为一对键值的值，因为元组本身不可变，所以该对键值的值不可变，但是不能因此认为字典的值不可改变。 2. 一对键值中，虽然字典也可以作为键值的值，而且在日常使用的时候也不会出现问题，但是在实际使用的时候，如果作为值的字典中存在bytes类的键值时，当尝试使用deepcopy复制字典实例的时候，可能会引发异常，当然类似的异常也会存在与复制相似结构的列表时诱发。各位可以留个印象，当以后遇见类似问题，或许可以帮助你确定异常诱发的原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mydict = &#123;<span class="string">"str"</span>: <span class="string">"String"</span>, <span class="string">"list"</span>: [<span class="string">"list1"</span>, <span class="string">"list2"</span>], <span class="string">"tuple"</span>: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) , <span class="string">"dictionary"</span> : &#123;<span class="string">"a"</span>: <span class="string">"1"</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mydict</span><br><span class="line">&#123;<span class="string">'list'</span>: [<span class="string">'list1'</span>, <span class="string">'list2'</span>], <span class="string">'dictionary'</span>: &#123;<span class="string">'a'</span>: <span class="string">'1'</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, <span class="string">'str'</span>: <span class="string">'String'</span>, <span class="string">'tuple'</span>: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">注：上述代码中我们会发现一个问题，字典键值打印时，键值组的顺序和自己声明字典时的顺序</span><br><span class="line">不一致。这样的问题在字典历遍或者索引的时候也会遇到。标准的Python中会有一个名为</span><br><span class="line">collections的模块，在该模块下有一个名为OderedDict的类，该类为Dict的子类，但具</span><br><span class="line">有保持字典中键值顺序与声明时相一致的特性。</span><br></pre></td></tr></table></figure><p>总的来说，对于字典中键值对，键是由唯一且不可变的数据类型定义，准确地来说是可以哈希（hashable）的数据类型。值可以为任意数据类型。当同一键值被重复赋值，最后一次值将被采用。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/LNbO7CDlxmbTEl8FZc5icO1wlmSzmh1hmz96edbdYgnGu6yzrRGLqSfoLLonV16JRlvMHD1qCQHbo6QtKzdu3uA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>声明后的字典实例，修改添加和改变都很简单。其中为字典中添加一个元素和更改一个元素的书写方式是一样的。如下方代码：如果字典情况位置，键3值的修改和键4值的添加，方法一样。而列表再添加值的时候是需要使用类方法append()的。而如果使用数字作为键值，代码文件就由如<strong>d[3] = ‘d’</strong> 的内容， 这样的书写方法不利于代码的标准化，而且类似的需求完全可以由列表来实现。所以个人建议为了代码的标准化，使用字典时，还是应尽量避免数值类型作为键的值，避免代码出现歧义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">3</span>]</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">3</span>] = <span class="string">'d'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">4</span>] = <span class="string">'e'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>字典的删除操作，使用字典的类方法clear()可以删除字典中的所有元素，但是字典实例依旧存在。也可以使用关键字<strong>del</strong>来实现对字典单一元素和整个字典的清除。注意：使用关键字del删除整个字典，该字典的实例将从内存中清除，使用被清除的字典会引发异常。如下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.clear()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123; <span class="number">1</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">3</span>: <span class="string">"c"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d[<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'d'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Dictionary-字典的索引"><a href="#Dictionary-字典的索引" class="headerlink" title="Dictionary 字典的索引"></a><strong>Dictionary 字典的索引</strong></h2><p>Python中字典键值的索引总的来说有两种方法，一种使用方括号和键，类似列表的方法来索引和访问字典中的元素。第二种是使用get()类方法和键来索引和访问，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">1</span>]</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line">&gt;&gt; d.get(<span class="number">1</span>)</span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure><p>两种方法在效率上并没有差别，早前读过一篇文章讨论两种索引方式的效率。结果如下，结果显示使用方括号更直接高效。个人建议大家将图示的结果仅作为一个参考，因为也有Python开发人员有不同意见，认为实验方式有问题。</p><p>在实际应用的时候，我个人觉得两种方法的效率其实并没有太大差别，更值得关注的是get()方法能够更好地避免因为键不存在引起的索引异常。如下面代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">6</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">KeyError: <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="number">6</span>, <span class="string">"No Value"</span>)</span><br><span class="line"><span class="string">'No Value'</span></span><br></pre></td></tr></table></figure><p>由上述代码可以发现，在遇到字典中不存在的键的问题的时候，方括号+键的方式会引发异常，为了避免异常还要添加代码（通常为if语句）来检测该字典中是否存在所求键值组。而使用get()方法则能避免引发这个异常，当字典中不存在所求键值组的时，使用该方法返回空，或者你也可以给定第二个变量作为默认值，当该键值不存在则会返回默认值。在实际使用中该方法优选，可以很大程度地减少代码数量。</p><p>在这里我给大家介绍一个Python字典索引的<strong>应用技巧</strong>，具体方法如下方代码。假如一个字典有数字和字符串混合键，想要得到所有数字键的键值组。经典方法为，索引字典中的每一个键值组，检查键的数据类型，将符合条件的键值组的值加入一个列表里面，最终就可以得到所有符合要求的键值组的值的组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'1'</span>: <span class="string">"a"</span>, <span class="number">1</span>:<span class="string">"b"</span>, <span class="string">'2'</span>: <span class="string">"c"</span>, <span class="number">2</span> : <span class="string">"d"</span>, <span class="string">'3'</span>: <span class="string">"e"</span>, <span class="number">3</span>: <span class="string">"f"</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'d'</span>, <span class="number">3</span>: <span class="string">'f'</span>, <span class="string">'1'</span>: <span class="string">'a'</span>, <span class="string">'3'</span>: <span class="string">'e'</span>, <span class="string">'2'</span>: <span class="string">'c'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.keys()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'1'</span>, <span class="string">'3'</span>, <span class="string">'2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intKeys = filter(<span class="keyword">lambda</span> e: isinstance(e, int), d.keys())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>intKeys</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listValuesOfIntKeys = map(d.get, intKeys)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listValuesOfIntKeys</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'f'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>使用上述方法，可以避免索引整个字典，代码简洁有效。这里值得关注的是使用filter()+lambda关键字来筛选一个列表，和使用map()函数一次性地用不同参数调用同一函数（在这里为字典的get()方法）。这样的方法或许可以提供一种不同的解决问题的思路。</p><p>索引的特殊情况，历遍字典所有键值组。经典方法为<strong>for + in</strong> 的组合来进行迭代。请参考下方代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br></pre></td></tr></table></figure><p>该种方法也有效，但是不推荐使用。主要原因在于，底层代码要检验键值的唯一性，该方法会增加发生异常的频率。还有一个原因是for循环中的d[key] 会导致键再次被哈希，当字典较大时，这样的操作会消耗更多的时间。</p><p>我个人比较推荐使用下面的方法，这样的方法同时迭代键与值，而且更见安全。这在Python 2.7 中常被使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.iteritems():</span><br></pre></td></tr></table></figure><p>Python 3.0 会使用下面的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br></pre></td></tr></table></figure><h2 id="关于字典的内置函数和类方法"><a href="#关于字典的内置函数和类方法" class="headerlink" title="关于字典的内置函数和类方法"></a><strong>关于字典的内置函数和类方法</strong></h2><p>字典作为Python的标准数据类型，Python这种语言自然为其准备了一些内置方法，常见的主要如下：</p><blockquote><ol><li>len(dict) 函数：用于得到字典的长度，因为为键值组，所以键的数量和值的数量相当。</li><li>str(dict) 函数：用于输出字典可打印的字符串，其表示内容，可通过继承字典类型， 复写<strong>repr</strong>(self)类函数来格式化输出内容。</li><li>cmp(dict1, dict2）函数：用于比较字典的键值组是否完全一致，如果相同则返回真， 否则为假。</li></ol></blockquote><p>字典在Python中也算是一种类，既然是类就有类方法。上文中介绍了一些常见的类方法比如使用键得到值的get()方法，清除字典内所有元素的clear()方法和得到字典内所有键值组键的方法keys()。 除此之外常用的方法还有：</p><blockquote><ol><li><p>dict.copy() 类方法： 用于浅复制一个字典， 注。</p></li><li><p>dict.items() 类方法：返回值为该字典”（键，值）“样式的元组组成的列表 ，注。</p></li><li><p>dict.update(dict2) 类方法：使用dict2中的值，来更新dict中有相同键的键</p><p>值组的值。</p></li><li><p>dict.values() 类方法：返回字典中所有值组成的列表。</p></li><li><p>dict.has_key(key) 类方法：用于判断字典中是否含有该键，有为true，否则为假。</p></li><li><p>dict.pop(key, default) 类方法：该方法与get()相似，删除一组键值，如果该键不</p><p>存在则返回default值。 注： Python 2.x中有iteritems方法，在Python 3.0 中该方法被items()替代。 关于浅复制和深复制的内容，我将为在以后的文章中介绍给大家。</p></li></ol></blockquote><p>使用Python语言的内置方法和字典的类方法并结合一下编程技巧，我相信，各位读者能够正确使用字典来解决自己在项目中遇见的问题， 并在完成项目的同时会发现一些新的技巧，进而不断地提高自己的代码质量和代码效率。</p><p>Python基本数据类型中的字典和其使用技巧今天就介绍到这里，我也会尽我所能提高更新频率。努力归纳自己在工作中遇见的问题，并把自己找到的解决方法介绍给大家。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 3. 基本语法" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 变量之元组与应用技巧</title>
    <link href="http://yoursite.com/2018/11/18/030103-variable-tuple-tips/"/>
    <id>http://yoursite.com/2018/11/18/030103-variable-tuple-tips/</id>
    <published>2018-11-18T07:11:08.000Z</published>
    <updated>2018-11-18T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h3 id="Python-标准数据类型"><a href="#Python-标准数据类型" class="headerlink" title="Python 标准数据类型"></a><strong>Python 标准数据类型</strong></h3><p>Python 定义了一些标准数据类型，用于存储各种类型的数据。Python有五个标准的数据类型，分别是：</p><ul><li><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><p>Python 变量申明自由，使用灵活，每种数据类型都有存在的原因和使用的技巧。今天的文章我们就介绍一下<strong>元组</strong>的基本知识，介绍一下它的使用技巧，讨论一下它存在的原因。</p></li></ul><p><img src="/2018/11/18/030103-variable-tuple-tips/971594283516_.pic.jpg" alt="img"></p><h3 id="Python-数据类型之元组"><a href="#Python-数据类型之元组" class="headerlink" title="Python 数据类型之元组"></a><strong>Python 数据类型之元组</strong></h3><p>前一篇文章提到的五种标准变量类型中string, list, tuple 都属于序列(sequence)类型。Python内置共有6种序列类型变量，分别为：</p><h2 id="str-unicode-list-tuple-buffer-xrange-range"><a href="#str-unicode-list-tuple-buffer-xrange-range" class="headerlink" title="str, unicode, list, tuple, buffer, xrange(range)"></a><code>str, unicode, list, tuple, buffer, xrange(range)</code></h2><p>除一种可变序列类型，即List列表，其余的如tuple和range都属于不可变的序列类型。这里所谓的”不可变” （immutable）是说，对象创建之后，就不可以通过一些操作改变其内部状态，简言之就是对象本身不可改变。</p><p><img src="/2018/11/18/030103-variable-tuple-tips/981594283545_.pic.jpg" alt="img"></p><h3 id="Python-元组赋值与快速赋值"><a href="#Python-元组赋值与快速赋值" class="headerlink" title="Python 元组赋值与快速赋值"></a><strong>Python 元组赋值与快速赋值</strong></h3><p>Python 元组使用圆括号“（）”，作为与其他数据类型区别的标志， 元素之间用逗号“，”分隔。元组在创建时元素的数据类型不限，可以是各种数据类型的集合。与列表相似，元组中的每个元素都分配一个数字作为索引，第一个索引值为0， 第二个为1，以此类推。元组列表普通赋值定义方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> )</span><br><span class="line">tup3 = (<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</span><br></pre></td></tr></table></figure><p>初始化完成之后就可以使用元组。元组和上一篇关于列表的文章相似。如果元组初始化长度过长，就可以使用下列方法对元组赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="number">0</span>,) * <span class="number">5</span> <span class="comment"># 数字类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 = (<span class="string">""</span>,) * <span class="number">8</span> <span class="comment"># 字符串类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup2 </span><br><span class="line">(<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3 = (<span class="literal">None</span>,) * <span class="number">9</span> <span class="comment"># 空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup3</span><br><span class="line">(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4 = (<span class="literal">True</span>, )*<span class="number">7</span> <span class="comment"># 布尔类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup4</span><br><span class="line">(<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>此方法快速高效，可以对指定长度的组元进行快速初始化，弊端在于不能在指定元素的类型，但可以按顺序混合元素的数据类型，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup5 = (<span class="literal">True</span>, <span class="string">""</span>)* <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup5</span><br><span class="line">(<span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>在这里要指出两点，一、此种快速赋值初始化元组理论上可行，但是不具有任何使用意义。理论上不存在，需要初始化一个元素相同的元组的情况。二、与列表不同，在初始化元组的候，如果元组中只有一个元素，那么需要在该元素后面添加逗号来消除歧义，如果没有，Python解释器会视为申明一个普通变量而非元组类型。</p><h3 id="Python-的列表索引，切片与排序"><a href="#Python-的列表索引，切片与排序" class="headerlink" title="Python 的列表索引，切片与排序"></a><strong>Python 的列表索引，切片与排序</strong></h3><p> Python 的元组索引方式和列表的索引方式相似：使用元组的变量名加方括号与索引值进行索引。Python的独特优势：在方括号中使用冒号“<strong>：</strong>”+“<strong>数字</strong>” 切片方式同样适用于元组。切片可以理解为：取元组中指定的<strong>连续</strong>元素，返回值同为元组。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1 = (<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">2</span>] <span class="comment"># 取第二个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">-1</span>] <span class="comment"># 取倒数第一个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">1</span>:] <span class="comment"># 取 从索引1至最后一个</span></span><br><span class="line">(<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[:<span class="number">2</span>] <span class="comment"># 取 从开始至索引2</span></span><br><span class="line">(<span class="string">'Google'</span>, <span class="string">'Runoob'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup1[<span class="number">-1</span>:] <span class="comment"># 取倒数第一个至倒数第一个</span></span><br><span class="line">(<span class="string">'Taobao'</span>,)</span><br><span class="line">注意：上述示例中，tup1[<span class="number">-1</span>]意为取最后一个，得到的结果为一个字符串类型，</span><br><span class="line">tup1[<span class="number">-1</span>:]也同为取最后一个，但因为指定了切片范围，则返回值为一个单一元素的元</span><br><span class="line">组。在编程时应注意这点，避免因数据类型问题写出很多不必要的代码。</span><br></pre></td></tr></table></figure><p>如同列表一样，元组在Python也是一个类。意味着元组有自己的类方法。可以通过类方法对元组进行操作。常用类方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    tup.count(obj) <span class="comment"># 某个元素在列表中出现的次数</span></span><br><span class="line"><span class="number">2</span>    tup.index(obj) <span class="comment"># 从列表中找出某个值第一个匹配项的索引位置</span></span><br></pre></td></tr></table></figure><p>感兴趣的可以对比一下<a href="http://mp.weixin.qq.com/s?__biz=MzU3MTI2ODk0MA==&mid=2247483757&idx=1&sn=32ceb9602e51d9964876cfc772b8034d&chksm=fce38b4ecb940258b0bc183b52ed4f43386e3a06334dda1f7e6396241957c8190be19782dbcd&scene=21#wechat_redirect" target="_blank" rel="noopener">上一篇关于列表</a>的文章，对比一下两者类方法相同与不同之处。简言之：<strong>元组不具有任何能改变自己的类方法</strong>。</p><p><img src="/2018/11/18/030103-variable-tuple-tips/991594283548_.pic.jpg" alt="img"></p><p>接下来我给大家介绍一下元组<strong>倒序排列</strong>(revers)和<strong>整理排序</strong>(sort)的应用技巧。整理排序时，默认情况下，数字元组排序规则为：由小到大；字符串元组排列规则：由“0”到“10”，然后由a到z；数字和字符串混合型元组排序规则为：先数字，后字符。请参考下方例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(tup) <span class="comment"># 使用Python内置方法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">注意，sorted()为Python编程语言的</span><br><span class="line">内置函数，元组不具有类似列表的类</span><br><span class="line">方法sort()用于排序。</span><br></pre></td></tr></table></figure><p>仔细观察上述示例，使用Python内置函数sorted()，返回值为一个列表，这与变量tup数据类型无关，仅与该函数的返回值类型有关。在元组倒序排列的问题，请参考下方例子，可以通过一种特殊的切片方法直接生成出一个倒序排列的新的元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup = (<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tup[::<span class="number">-1</span>] <span class="comment"># 采用切片法</span></span><br><span class="line">(<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reversed(tup)</span><br><span class="line">&lt;reversed object at <span class="number">0x00000000002AEED68</span>&gt;</span><br></pre></td></tr></table></figure><p>虽然python也有一个用于倒序排列的内置函数reversed() 也可以用于元组。此函数返回值为一个元组型的迭(die)代器实例，而非一个新的元组，所以说用类似“<strong>[::-1]</strong>”切片方式才是元组倒序排列的最佳选择。</p><p>Python编程语言一些内置函数，比如：元组间比较cmp()，获取长度len()，最大值max()和最小值min()，转变为列表list(seq)等，这些函数不仅适用于列表，也同样适用于元组，毕竟两者都属于序列类型。如上篇文章所介绍的，用于检测是否为<strong>非空</strong>的函数all()，和是否有任一个元素为<strong>空</strong>的函数any也能用于元组。</p><h3 id="列表与元组"><a href="#列表与元组" class="headerlink" title="列表与元组"></a><strong>列表与元组</strong></h3><p>如果大家开始学习Python，学到这里的时候，脑子里都应该有这样一个问题，Python中有列表这种数据类型，为什么还需要一个元组。接下来我们来探讨一下其存在的原因。</p><p>列表和元组两者是相似的数据类型，都是作为一个容器，用于存储数据。本质上都属于序列类型，但列表可变，元组不可变。除了关注”变”以外，理论上我们还需要注意他们在语法上的应用区别，元组应当作为异构的数据集合（元素数据类型不同），类似于C语言里面的struct 结构体；列表应当作同构的数据集合（元素数据类型相同），类似与C语言中的array数组。两者在Python中的使用原则应为，<strong>元组关注结构，列表关注排列</strong>。但在实际应用中，因为Python的列表并不限制数据类型，所以这一原则并没有被严格遵守。</p><p>元组使用场景通常为：同时为多个变量名赋值；一次性为函数传递所有参数和调用函数时一次性返回不同的类型的数据，如下：</p><ul><li>场景一，为多个变量名同时赋值：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># case 1： 使用元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment"># case 2： 使用列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>   <span class="comment"># case 3： 此种方法也视为 元组赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = d         <span class="comment"># case 4： 此种方法也视为 元组赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c = d         <span class="comment"># case 5： 此种方法也视为 元组赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, c</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>虽然上述场景中，case1与case2, case4与case5能达到相同的目的但是本质上来讲case2和case5都是由Python解释权将列表转换为元组，然后再给a, b, c三个变量赋值的。case3比较特殊，虽然没有使用圆括号，但是Python的解释权会自动讲”1， 2， 3“ 转换为元组，然后进行赋值。</p><ul><li>场景二，一次性为函数传递所有参数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(a=<span class="string">""</span>, b=None, c=False)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"a : "</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> a,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">" b : "</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> b,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">" c : "</span>,</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> c</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)     <span class="comment"># 使用元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(d)           <span class="comment"># 错误方式</span></span><br><span class="line">a :  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  b :  <span class="literal">None</span>  c :  <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(*d)          <span class="comment"># 正确方式a :  1  b :  2  c :  3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]     <span class="comment"># 使用列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(d)           <span class="comment"># 错误方式</span></span><br><span class="line">a :  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  b :  <span class="literal">None</span>  c :  <span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun1(*d)          <span class="comment"># 正确方式</span></span><br><span class="line">a :  <span class="number">1</span>  b :  <span class="number">2</span>  c :  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>同样的虽然上述场景中，使用列表和元组通过正确地方式都能够一次性地传递多个参数给函数fun1()。 但是与场景一相同，都是由Python解释权将列表转换为元组，然后再给a, b, c三个参数赋值的。</p><p> 场景三，调用函数时一次性返回不同的类型的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"HalloWorld"</span>, <span class="number">1</span>, <span class="literal">False</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun2()</span><br><span class="line">(<span class="string">'HalloWorld'</span>, <span class="number">1</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>上述场景中的问题，<strong>只能</strong>通过元组来实现（圆括号有与无，都为元组）。虽然也可以定义一个列表，将所有返回值打包然后返回一个列表，但是会产生许多不必要的代码，还需要索引使用返回值，过于繁琐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>): <span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]: <span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">"123"</span>: <span class="keyword">print</span> x</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>在做上述相同工作的时候，列表和远足可以得到相似的结果，但是效率上呢？我们做些测试，如下：</p><p>测试一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python -mtimeit <span class="string">"['fee', 'fie', 'fo', 'fum']"</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">0.432</span> usec per loop</span><br><span class="line">$ python -mtimeit <span class="string">"('fee', 'fie', 'fo', 'fum')"</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">0.0563</span> usec per loop</span><br></pre></td></tr></table></figure><p>测试二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = tuple(range(<span class="number">1000</span>))</span><br><span class="line">b = list(range(<span class="number">1000</span>))</span><br><span class="line">a.__sizeof__() <span class="comment"># 8024</span></span><br><span class="line">b.__sizeof__() <span class="comment"># 9088</span></span><br></pre></td></tr></table></figure><p>第一个测试中，我们分别创建元素相同的列表和元组。然后测试Python解释器创建它们所需时间，进而得出最优值。我们可以发现元组的创建时间是列表创建时间的八分之一。第二个测试中，我们尝试初始化相同长度的元组和列表，然后比较两个所需内存大小，结果现实元组相比列表所需内存相对较少。总而言之：元组的性能优于列表。在需要关注性能与内存使用率的时候，元组还是最优选择。</p><p>但如果作为仅作为序列型的数据，忽略两者性能上的差异，列表可以完全替代元组解决程序中遇到的问题。这样的话，是不是在Python中，元组就没有专属的应用场景了呢？是不是就不存在非元组不可的情况呢？<strong>当然不是</strong>。</p><p>列表作为可变序列，是不可以成为字典（dictionary，Python的一种数据类型）的键值（即key）的，而元组为不可变序列则可以作为键值。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a    = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">b    = [<span class="number">1</span>,<span class="number">2</span>] </span><br><span class="line">c = &#123;a: <span class="number">1</span>&#125;     <span class="comment"># 合法</span></span><br><span class="line">c = &#123;b: <span class="number">1</span>&#125;     <span class="comment"># 非法</span></span><br></pre></td></tr></table></figure><p>该种情况的使用场景为：如果需要将<strong>经纬度</strong>当多一个字典的键值时；如果需要将<strong>行列值</strong>作为一个字典的键值是；如果需要讲<strong>屏幕位置</strong>作为一个字典的键值等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 3. 基本语法" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 变量之列表与应用技巧</title>
    <link href="http://yoursite.com/2018/11/15/030102-variable-list-tips/"/>
    <id>http://yoursite.com/2018/11/15/030102-variable-list-tips/</id>
    <published>2018-11-15T07:11:08.000Z</published>
    <updated>2018-11-15T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><h3 id="Python-标准数据类型"><a href="#Python-标准数据类型" class="headerlink" title="Python 标准数据类型"></a><strong>Python 标准数据类型</strong></h3><p>Python 定义了一些标准数据类型，用于存储各种类型的数据。Python有五个标准的数据类型，分别是：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><p>Python 中的变量赋值不需要类型声明，也就是说声明变量不需要使用关键字。Python 中变量赋值之后该变量就被创建。可以简单对单一变量赋值，亦可对同一变量重新赋值（不同数据类型也可以），也可以同时为多个变量赋值，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span> <span class="comment"># 赋值整型变量</span></span><br><span class="line">miles = <span class="number">1000.0</span> <span class="comment"># 浮点型</span></span><br><span class="line">name = <span class="string">"John"</span> <span class="comment"># 字符串</span></span><br><span class="line">ame = <span class="number">100</span> <span class="comment"># ame 被定义为新的数据类型</span></span><br><span class="line">ame1 = ame2 = ame3 = <span class="number">100</span> <span class="comment">#此三个变量被同时定义和赋值</span></span><br></pre></td></tr></table></figure><h3 id="Python-数据类型之列表"><a href="#Python-数据类型之列表" class="headerlink" title="Python 数据类型之列表"></a><strong>Python 数据类型之列表</strong></h3><p>Python的变量灵活多变，不同的变量类型也有不同的使用技巧。上述的五种标准变量类型中string, list, tuple 都属于序列(sequence)类型。Python内置共有6种序列类型变量，分别为：</p><h2 id="str-unicode-list-tuple-buffer-xrange-range"><a href="#str-unicode-list-tuple-buffer-xrange-range" class="headerlink" title="str, unicode, list, tuple, buffer, xrange(range)"></a><code>str, unicode, list, tuple, buffer, xrange(range)</code></h2><p>其中只有一种可变序列类型，即List列表，其余的如tuple和range（关于xrange和range的区别，我会在以后总结介绍，或者可以在百度知道搜索#<strong>python for in原理</strong>#参考我的回答）都属于不可变的序列类型。这里所谓的”变” （mutable）是说，在对象创建之后，可以通过一些操作改变其内部状态，简言之就是改变对象本身。因为最近的工作遇到了很多关于列表的问题，今天我就借助这篇文章给大家介绍Python基本变量类型中的List，同时也给大家介绍一下List和Python内置函数相互配合的使用技巧。</p><h3 id="Python-列表赋值与快速赋值"><a href="#Python-列表赋值与快速赋值" class="headerlink" title="Python 列表赋值与快速赋值"></a><strong>Python 列表赋值与快速赋值</strong></h3><p>Python 列表使用方括号“[ ]”， 元素之间用逗号“，”分隔。列表元素的数据类型不限，可以是各种数据类型的集合，这点要比其他编程语言方便。列表元素个数不限，理论上只要内存足够大，元素个数就可以无限大。列表中的每个元素都分配一个数字作为索引，第一个索引值为0， 第二个为1，以此类推。List 列表普通赋值定义方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">list3 = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>]</span><br></pre></td></tr></table></figure><p>然后就可以使用列表，但是在一些实际应用中需要初始化给定长度的列表，并对列表中每一个元素进行赋<strong>初值</strong>。如果列表长度在10以内，普通赋值依旧适用。如果列表长度过长，有可能需要写个循环进行赋值。<strong>技巧</strong>：可以使用下列方法对列表进行赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [<span class="number">0</span>] * <span class="number">5</span> <span class="comment"># 数字类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2 = [<span class="string">""</span>] * <span class="number">8</span> <span class="comment"># 字符串类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list2</span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3 = [<span class="literal">None</span>] * <span class="number">9</span> <span class="comment"># 空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list3</span><br><span class="line">[<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list4 = [<span class="literal">True</span>] *<span class="number">7</span> <span class="comment"># 布尔类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list4</span><br><span class="line">[<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span>]</span><br></pre></td></tr></table></figure><p> 该方法快速高效，可以对指定长度的列表进行快速初始化，弊端在于不能在限定元素的类型，但可以按序混合元素的数据类型，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list5 = [<span class="literal">True</span>, <span class="string">""</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list5</span><br><span class="line">[<span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>, <span class="literal">True</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure><h3 id="Python-的列表索引，切片，改变与排序"><a href="#Python-的列表索引，切片，改变与排序" class="headerlink" title="Python 的列表索引，切片，改变与排序"></a><strong>Python 的列表索引，切片，改变与排序</strong></h3><p>Python 的列表索引方式和其他编程语言相似，即使用列表变量名，方括号与索引值进行索引。但Python与其他语言相比又有独特优势。即在方括号中使用冒号“<strong>：</strong>”+“<strong>数字</strong>” 对列表进行切片。切片可以理解为：取列表中指定的<strong>连续</strong>元素。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1 = [<span class="string">'Google'</span>, <span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[<span class="number">2</span>] <span class="comment"># 取第二个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[<span class="number">-1</span>] <span class="comment"># 取倒数第一个</span></span><br><span class="line"><span class="string">'Taobao'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[<span class="number">1</span>:] <span class="comment"># 取 从索引1至最后一个</span></span><br><span class="line">[<span class="string">'Runoob'</span>, <span class="string">'Taobao'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>List1[:<span class="number">2</span>] <span class="comment"># 取 从开始至索引2</span></span><br><span class="line">[<span class="string">'Google'</span>, <span class="string">'Runoob'</span>]</span><br></pre></td></tr></table></figure><p>Python 的列表是一个类的实例，也就意味着列表有自己的类方法。可以通过类方法对列表进行改变或者其他操作。常用类方法如下：</p><ol><li>list.append(obj) # 在列表末尾添加新的对象</li><li>list.count(obj) # 某个元素在列表中出现的次数</li><li>list.extend(seq) # 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li><li>list.index(obj) # 从列表中找出某个值第一个匹配项的索引位置</li><li>list.insert(index, obj) # 将对象插入列表</li><li>list.pop(obj=list[-1]) # 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li><li>list.remove(obj) # 移除列表中某个值的第一个匹配项</li><li>list.reverse() # 反向列表中元素</li><li>list.sort([func]) # 对原列表进行排序</li></ol><p>在这里我给大家介绍一下列表操作中，<strong>倒序排列</strong>(revers)和<strong>整理排序</strong>(sort)的应用技巧。整理排序时，默认情况下，数字列表排序规则为：由小到大；字符串列表排列规则：由“0”到“10”，然后由a到z；数字和字符串混合型列表排序规则为：先数字，后字符。请参考下方例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(lt) <span class="comment"># 使用内置方法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt.sort() <span class="comment"># 使用类方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    </span><br><span class="line">注意，sort() 为数据类型列表的类方法，</span><br><span class="line">sorted()为Python编程语言的内置函数。</span><br></pre></td></tr></table></figure><p>由上述例子可知，使用Python内置函数，返回值为一个列表，使用列表的类方法则返回值为空。意思就是说：在整理排序时，内置函数不改变原始列表，而使用类方法则原始列表将发生变化。在处理某些问题的时候，我们需要保持原始列表不变，这时候就应该考虑，哪一种方法更合适。这样的情况在倒序排列的时候也会发生，使用reverse()类方法时，虽然得到了倒序排列的列表，但是列表本身发生了变化，为了避免类似情况发生，备份一下原始列表是一种方法，但是会比较复杂。在这里我给大家介绍一个实用技巧。我们可以通过一种特殊的列表切片方法直接生成出一个倒序排列的新的列表，请参考下方例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">"c"</span>, <span class="number">3</span>, <span class="string">"b"</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt[::<span class="number">-1</span>] <span class="comment"># 采用切片法</span></span><br><span class="line">[<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lt.reverse() <span class="comment"># 采用类方法</span></span><br><span class="line">&gt;&gt; lt</span><br><span class="line">[<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="number">1</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><p>虽然python也有一个用于倒序排列的内置函数reversed(). 但是与sorted()函数不同，此函数返回值为一个列表迭(die)代器实例（iterator，以后的文章会详细介绍迭代器）而非一个新的列表，所以说用类似“<strong>[::-1]</strong>”的列表切片更为合适。</p><p>Python编程语言还有一些其它的内置函数用于处理列表。比如：不同列表间比较cmp(list1, list2)，获取列表长度len(list)，最大值max(list)最小值min(list)，将元素变为列表list(seq)等。</p><blockquote><p>Tipp 1: 虽然list不是python的保留字符 可以用list作为变量名，而且不会产生错误。 但是还是不建议使用其作为变量名。</p><p>Tipp 2: 其实python还有其他的不经常用到 的内置函数: 用all(list)来检查列表中是否所有元素都 为非空。 用any(list)来检查列表中是否有任何一个 为空。</p></blockquote><h3 id="Python-列表数据类型转换和应用技巧"><a href="#Python-列表数据类型转换和应用技巧" class="headerlink" title="Python 列表数据类型转换和应用技巧"></a><strong>Python 列表数据类型转换和应用技巧</strong></h3><p>列表数据转换问题，一般分为两种情况。列表中元素的数据类型转换问题和整个列表数据类型转换问题。</p><p>列表元素数据类型转换，常见问题为数值类型和字符串类型间转换。例如将列表中的数字化字符串元素转换为数值类型元素，或反之； 或者将字符串列表的所有元素拼接，或反之。请参考下面例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ll = [<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>, <span class="number">5.6</span>] <span class="comment"># 将数值型转换为字符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ll</span><br><span class="line">[<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>, <span class="number">5.6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(str, ll)</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2.3'</span>, <span class="string">'3.4'</span>, <span class="string">'4.5'</span>, <span class="string">'5.6'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = [<span class="string">'1'</span>, <span class="string">'2.3'</span>, <span class="string">'3.4'</span>, <span class="string">'4.5'</span>, <span class="string">'5.6'</span>]  <span class="comment"># 将字符型转换为数值型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(float, ss)</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">2.3</span>, <span class="number">3.4</span>, <span class="number">4.5</span>, <span class="number">5.6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tt = [<span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span>] <span class="comment"># 元素拼合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tt</span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">""</span>.join(tt)</span><br><span class="line"><span class="string">'hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">"hello"</span>  <span class="comment"># 字符串拆分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(st)</span><br><span class="line">[<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure><p> 列表整体式地数据类型转换，常见问题：将列表整体转换为一个字符串和将一个字符串中的<strong>列表部分</strong>转换为一个列表。第一种情况请参考下方例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = [<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss</span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(ss)</span><br><span class="line"><span class="string">"['a', 1, 'c', 3, 'b', 2]"</span></span><br></pre></td></tr></table></figure><p>可以看出只需要使用python的内置方法str()就实现。可是如果是第二种情况呢？如果要将字符串化的列表转换为一个列表，<strong>千万不要</strong>使用内置函数list()。因为不会得到预期的结果，这里要使用内置函数eval()。参考下方代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">"['a', 1, 'c', 3, 'b', 2]"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(st) <span class="comment"># 若使用list函数</span></span><br><span class="line">[<span class="string">'['</span>, <span class="string">"'"</span>, <span class="string">'a'</span>, <span class="string">"'"</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'1'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">"'"</span>, <span class="string">'c'</span>, <span class="string">"'"</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'3'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">"'"</span>, <span class="string">'b'</span>, <span class="string">"'"</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'2'</span>, <span class="string">']'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(st) <span class="comment"># 若使用eval函数</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="string">'b'</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>Python基本数据类型中的List列表和列表的使用技巧今天就介绍到这里。想比大家都有这样的印象：如果能合理并巧妙地使用python内置函数来处理列表，将能够大大减少代码数量和提高代码质量。如果大家有别的想法或者其他使用技巧。欢迎订阅我的个人微信公共号，留言分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 3. 基本语法" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Python 变量之字符串与应用技巧</title>
    <link href="http://yoursite.com/2018/11/12/030101-variable-string-tips/"/>
    <id>http://yoursite.com/2018/11/12/030101-variable-string-tips/</id>
    <published>2018-11-12T07:11:08.000Z</published>
    <updated>2018-11-12T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><p> Python 定义了一些标准数据类型，用于存储各种类型的数据。Python有五个标准的数据类型，分别是：</p><ul><li><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul></li></ul><p>字符串作为Python编程的常用数据类型，在代码中出现的频率相当高。今天借着这篇文章来给大家介绍一下关于Python编程中，String字符串这种数据类型的基本知识和实际运用中会遇到的问题及解决方法，同时也给大家介绍一些常用的使用技巧。</p><p><img src="/2018/11/12/030101-variable-string-tips/640-20200709090923198.png" alt="img"></p><h3 id="String字符串的特征"><a href="#String字符串的特征" class="headerlink" title="String字符串的特征"></a><strong>String字符串的特征</strong></h3><p>前几篇文章中都有介绍，Python的变量声明简单明确。字符串类型的变量声明也十分简单，任何用引号包裹的内容都可以理解为字符串，无论是单引号（single quotes），或者是双引号 （double quotes）, 还是三引号（triple quotes）。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">'Hallo World'</span>  <span class="comment"># 单引号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">"Hallo World"</span>  <span class="comment"># 双引号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">"""Hallo World"""</span>  <span class="comment"># 三引号</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>st = <span class="string">u"Hallo World"</span>  <span class="comment"># unicode 宽字符串</span></span><br></pre></td></tr></table></figure><p>有时作为输出需要，还是要将引号本身作为字符串的一部分输出来了。这时候需要引号套用，在Python中，每种引号都可以包含其他的引号，如果要包含引号自身则需要”转义”。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'Hallo " World'</span>  <span class="comment"># 单引号 包含双引号</span></span><br><span class="line">Hallo <span class="string">" World</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print 'Hallo "</span><span class="string">""</span> World<span class="string">' # 单引号 包含双引号</span></span><br><span class="line"><span class="string">Hallo """ World</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print "Hallo '</span> World<span class="string">"   # 双引号 包含单引号</span></span><br><span class="line"><span class="string">Hallo ' World</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print 'Hallo \' World'  # 单引号 包含单引号（转义）</span></span><br><span class="line"><span class="string">Hallo ' World</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print r'Hallo \' World'  # 停止 转义</span></span><br><span class="line"><span class="string">Hallo \' World</span></span><br><span class="line"><span class="string">“转义” 的意思是告诉解释器或编译器，转义符后面的一个或者几个</span></span><br><span class="line"><span class="string">字符串要使用一种替代的解释或者编译方式。</span></span><br></pre></td></tr></table></figure><p>“转义”在很多程序语言中都有用到。那么问题来了，Python中的转移符号位反斜杠”&quot;。如果根据输出需要：在单引号包含单引号（转义）的情况下，在包含的单引号前显示一个反斜杠符号”&quot;，该如何实现。方法如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'Hallo \' World'</span>  <span class="comment"># 为了显示包含的单引号</span></span><br><span class="line">Hallo <span class="string">' World</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print '</span>Hallo \\\<span class="string">' World'</span> <span class="comment"># 为了现实单引号和反斜杠</span></span><br><span class="line">Hallo \<span class="string">' World</span></span><br></pre></td></tr></table></figure><p>上面的例子中第二行代码中的&lt;<strong>\‘</strong>&gt;。这部分内容应该这样理解：第三个反斜杠是用于转义单引号字符。第一个反斜杠是用于转义第二个反斜杠。转义符的复用和套用会在实际应用中经常出现，如在处理字符串的大杀器<strong>正则表达式</strong>中，许多语法就用到转移符。如果能够正确使用转义符，也有助于快速理解代码和准确调试代码。</p><p>上一篇文章介绍过，Python中的字符也属于序列类型(Sequence)，且为非可变序列类型，作为序列，它可以是迭代(iterable)，可以历遍(traverse)。这样的就赋予了字符串一些特殊的性能。比如类似与元组，可以使用for或者enumerate来历遍整个字符串中的字符。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> a <span class="keyword">in</span> <span class="string">"Hallo World"</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> a</span><br><span class="line">...</span><br><span class="line">H</span><br><span class="line">a</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(<span class="string">"Hallo World"</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> `i` + <span class="string">" "</span> + a</span><br><span class="line"><span class="number">0</span> H</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> l</span><br><span class="line"><span class="number">3</span> l</span><br><span class="line"><span class="number">4</span> o</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在判断元素是否存在与序列中是， 用到的逻辑判断关键字 <strong>in</strong> 和 <strong>not in</strong> 也适用于字符串。 类似元组和列表的索引和切片方式也同样适用于字符串，在这里就不赘述了。需要指出，在逻辑判断时，准确地说，在比较两个字符串是否相等时，虽然可以使用关键字 “<strong>is</strong>“ 或逻辑判断符 “<strong>==</strong>“ 或者<strong>cmp( )</strong> 函数等。但是三者还是有所不同的。在Python中 “is” 是用于判断两个变量是否引用的是同一对象；逻辑判断符 “==” 用于判断两个变量的值是否相同；cmp( ) 函数的用法和逻辑判断符 “==” 相似。在Python3 中，该函数被移除了。考虑到代码的兼容性和稳定性，建议在对比字符串是否相同时采用逻辑判断符 “==”。</p><p>值得注意的是，上述的例子中我用到了反引号，在Python中<strong>反引号</strong>，内置函数<strong>str( )</strong> 和<strong>repr( )</strong> 都是用来将非字符串类型转换为字符串类型的。 三者相似但不相同：</p><blockquote><ol><li><p>反引号， 该语法只适用于Python2.7 中，Python3.0已经不再</p><p>支持该语法。</p></li><li><p>str（）， 使用该方法得到的字符串具有很好的可读性。非常适</p><p>用于print的输出。</p></li><li><p>repr（）， 用于返回一个类实例的标准字符串表示，至于如何</p><p>表现，可以在类中的<strong>repr</strong>(self)，方法中定义。该方法的</p><p>特点为，该方法一般情况下：</p><p>适用等式：  obj = eval(repr(obj)) 。意味着可以使用该等</p><p>式从字符串中重新获得该对象。</p></li></ol></blockquote><p>需要强调：字符串作为<strong>不可变</strong>序列。意味着，字符在初始化之后，就<strong>不能</strong>再对字符串的实例进行改变。字符串的自加和拼接，虽然都可以使用相同的变量名来接收新的值，但本质上是申明了一个新的字符串变量，只是名字相同而已，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_string = <span class="string">"AAA "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(my_string)</span><br><span class="line"><span class="number">42835040L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_string += <span class="string">"AAA "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(my_string)</span><br><span class="line"><span class="number">42794176L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_string = <span class="string">"AAA "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(my_string)</span><br><span class="line"><span class="number">42834960L</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_string = <span class="string">"AAA "</span>  +  <span class="string">" BBB"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(my_string)</span><br><span class="line"><span class="number">42794416L</span></span><br></pre></td></tr></table></figure><p>由上述例子可知，虽然使用了相同的变量名，用来接收新的值，但随着字符串变量值的变化，对象的id也发生了变化，也就意味着虽然变量名称不变，但是其本质上已经是一个<strong>新的变量</strong>。</p><h3 id="String字符串的类方法"><a href="#String字符串的类方法" class="headerlink" title="String字符串的类方法"></a><strong>String字符串的类方法</strong></h3><p>字符串作为一个类，即对象。也就意味了它会有类方法和类属性，随着Python的日渐完善。字符串的类方法也日渐健全与强大，字符串的类方法有很多，在此只列举出一些经常遇见的类方法，请看下方表格：</p><table><thead><tr><th align="left"></th><th align="left"></th></tr></thead><tbody><tr><td align="left">string.isalnum()</td><td align="left">判断 string 中是否所有字符都是字母或数字。是则返回 True,否则返回 False</td></tr><tr><td align="left">string.isalpha()</td><td align="left">判断 string 中是否含有字符并且所有字符都是字母，是则返回 True,否则返回 False</td></tr><tr><td align="left">string.isdecimal()</td><td align="left">判断 string 中是否只包含十进制数字，是返回 True 否则返回 False.</td></tr><tr><td align="left">string.isdigit()</td><td align="left">判断 string 中是否只包含数字，是则返回 True，否则返回 False.</td></tr><tr><td align="left">string.islower()</td><td align="left">判断 string 中是否包含一个或者多个区分大小写的字符，字符都是小写。则返回 True，否则返回 False</td></tr><tr><td align="left">string.istitle()</td><td align="left">判断 string 中是否第一个字符为大写。是则返回 True，否则返回 False</td></tr><tr><td align="left">string.isupper()</td><td align="left">判断string 中是否所以字符都是大写。 则返回 True，否则返回 False</td></tr><tr><td align="left">string.lower()</td><td align="left">讲转换 string 中所有字符转变为小写.</td></tr><tr><td align="left">max(str)</td><td align="left">返回字符串 <em>str</em> 中最大的字母，参考 ascii 表。</td></tr><tr><td align="left">min(str)</td><td align="left">返回字符串 <em>str</em> 中最小的字母，参考 ascii 表。</td></tr><tr><td align="left">string.title()</td><td align="left">将所有单词都是的第一个字母大写，其余字母均为小写</td></tr><tr><td align="left">string.upper()</td><td align="left">转换 string 中的所有字母改为大写</td></tr></tbody></table><p>熟练掌握上述类方法在Python编程中很有益处，比如：在遇见到需要将数字型的字符串转化为数值型变量时。如果可以先使用string.isdigit()这个类方法对变量进行检查，就能够避免因出现转换异常（Exception）造成整个程序的意外退出。</p><p>与类方法相匹配，Python还提供了一些模块用于辅助处理字符串。例如，常见的文件操作中，需要对文件路径进行处理。该变量在Python也是字符串类型。如需要对路径进行拼接和拆分，获取文件名或文件后缀类型。Python中的os.path模块就非常适合做这样的工作，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_path = <span class="string">"C:\\temp\main.py"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.split(my_path)</span><br><span class="line">(<span class="string">'C:\\temp'</span>, <span class="string">'main.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.splitext(my_path)</span><br><span class="line">(<span class="string">'C:\\temp\\main'</span>, <span class="string">'.py'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.join(<span class="string">"C:\\tmp"</span>, <span class="string">"main.py"</span>)</span><br><span class="line"><span class="string">'C:\\tmp\\main.py'</span></span><br></pre></td></tr></table></figure><p>在处理路径是，申明路径字符串变量时，尽量使用<strong>双反斜杠</strong>，这样可以避免一些错误异常。如果我们使用os.path模块下的函数来处理路径，就能够尽可能地避免很多对反斜杠的操作。代码也能够简洁高效。</p><h3 id="String字符串的转码问题"><a href="#String字符串的转码问题" class="headerlink" title="String字符串的转码问题"></a><strong>String字符串的转码问题</strong></h3><p>常见的字符处理事务中还会遇见字符串转码问题。由于计算机只能处理数字，处理文本类的时候也需要先将文本类转换为数字。在编程中，字符串独立作为一种数据类型，但是其本身在内存中也是一组数字。如何将文本类转换为数字，就是我们要讨论的编码问题。</p><p>Unicode也称为宽字节字符。Unicode的目的是将所有语言都统一到一套编码里，从而避免乱码问题。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字母 A 用ASCII编码是十进制的65，二进制的01000001。</span><br><span class="line">字母 A 用Unicode编码，  编码是00000000 01000001。</span><br></pre></td></tr></table></figure><p>可以看出，如果将字母 A 转变成 Unicode，则编码长度变长，但其值不发生变化，因为低字节已经足以满足要求，但最为宽体字符我们需要在高字节补零。如果一个Unicode字符，其高字节不全为零，强制性将其转换为ASCII编码字符。就会发生错误: 超出编码范围。</p><p>文中插图中强调 “unicode” != “utf-8” 。意思是说utf-8是编码方式，除了常见的的uft-8还有utf-16，以及中文编码方式gbk等等。unicode 则是这些转码后的宽字符串的统称。在Python中，可以将unicode理解为一种新的字符串数据类型。该字符串与普通ascii字符串用法相似，但它能够接收和处理非ascii编码的文本类型。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: gbk -*-</span></span><br><span class="line">string=<span class="string">'中国'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string: "</span>, type(string)</span><br><span class="line"><span class="keyword">print</span> string</span><br><span class="line"></span><br><span class="line">ustring=<span class="string">u"中国"</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"ustring: "</span>,</span><br><span class="line">type(ustring)</span><br><span class="line"><span class="keyword">print</span> ustring</span><br><span class="line"></span><br><span class="line">gbkstring=ustring.encode(<span class="string">"gbk"</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"gbkstring: "</span>, type(gbkstring)</span><br><span class="line"><span class="keyword">print</span> gbkstring</span><br></pre></td></tr></table></figure><p> 输入结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string: &lt;type <span class="string">'str'</span>&gt;</span><br><span class="line">我的</span><br><span class="line">ustring: &lt;type <span class="string">'unicode'</span>&gt;</span><br><span class="line">鎴戠殑</span><br><span class="line">gbkstring: &lt;type <span class="string">'str'</span>&gt;</span><br><span class="line">我的</span><br></pre></td></tr></table></figure><p>上述例子中unicode接收了宽体字符，它也作为媒介用于实现字符串编码的转换。而只有准确的将unicode编码解码，才能得到正确的结果。</p><h3 id="String字符串的查找与替换"><a href="#String字符串的查找与替换" class="headerlink" title="String字符串的查找与替换"></a><strong>String字符串的查找与替换</strong></h3><p>处理String字符串的终极问题是：从字符串特定位置，得到符合特定条件的子字符串或者在符合特定条件的位置插入子字符串。解决类似问题的大杀器就是Python的<strong>正则表达式</strong>。文章篇幅问题，关于正则表达式的内容在以后的文章里面介绍。本文就简单介绍一下find( ) 和 replace( ) 两个函数。</p><p>find也好repleace 也罢，都是string类的类方法，可作为实例方法，也可以作为该类的静态方法。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> string</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_str = <span class="string">'abca'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_str.find(<span class="string">'a'</span>)  <span class="comment"># 实例方法</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.find(my_str, <span class="string">'a'</span>)  <span class="comment"># 静态方法</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_str.find(<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string.find(my_str, <span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>要找到特定字符在字符串中的位置，最好是给定查找的初始位置。默认情况下初始位置为零，而且该方法找到即返回，不会迭代查找。如果没有找到则返回值为-1，这里的 “-1” 可以用于逻辑判断。</p><p>repleace方法和find方法近似。但是默认情况下会替换字符串中所有符合条件的字符。如果想删除字符串中的某些字符，则可以将用于替换的字符设置为空，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str =<span class="string">"ab1cd1ef"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str.replace(<span class="string">"1"</span>,<span class="string">""</span>)</span><br><span class="line"><span class="string">'abcdef'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>Python基本数据类型中的字符串和其使用技巧今天就介绍到这里。欢迎订阅我的个人微信公共号，如果您有问题或者不同见解，请在下方留言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 3. 基本语法" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-3-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="变量" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F/"/>
    
      <category term="应用技巧" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS系统下 Python的安装配置</title>
    <link href="http://yoursite.com/2018/11/11/0203-os-mac/"/>
    <id>http://yoursite.com/2018/11/11/0203-os-mac/</id>
    <published>2018-11-11T07:11:08.000Z</published>
    <updated>2018-11-11T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><p>由于Python日渐流行，已知的是，较新版本的Mac OS也已经预装了Python 2.7的版本。 比如OS X 10.8至10.10系统已经自带的Python版本是2.7。</p><p>但是可能存在的问题是，系统自带的2.7.x的版本相对较老，如果需要安装最新的2.7和3.0版本，可以借助Homebrew 来解决问题。</p><p>在Homebrew安装之前，需要检查系统里是否已经安装了Xcode，若没有可以在应用商店里查询Xcode并安装。</p><p>然后就可以安装Homebrew，在终端里面输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><p>来安装Homebrew，在安装结束之后需要将Homebrew的安装路径告知Mac OS系统。方法是：</p><p>在当前用户根目录下找到个人配置文件即：<strong>~/.profile</strong> 文件末尾加入下列内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:$PATH</span><br></pre></td></tr></table></figure><p>然后就可以使用Homebrew安装最新版本的Python了。</p><p>安装Python3.x 在终端里键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install python3</span><br></pre></td></tr></table></figure><p>安装最新Python2.x 在终端里键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install python</span><br></pre></td></tr></table></figure><p>值得注意的是：Homebrew会将Python2.7的解释器命名为python2。而系统自带的Python还是用python来运行，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python -V   # 系统Python解释器</span><br><span class="line"></span><br><span class="line">$ python2 -V  # Python 2解释器</span><br><span class="line"></span><br><span class="line">$ python3 -V  # Python 3解释器（如果安装了）</span><br></pre></td></tr></table></figure><p>在用Homebrew安装Python的同时，pip也会被安装，其中pip2 管理最新的Python2.7的第三方扩展库 （非系统自带）。其中pip3 管理最新的Python3.x的扩展库。</p><p>因为最新的电脑里面还没安装Mac OS的虚拟机。所以上所写的是之前笔记中的内容，可能与目前情况有出入。如有问题，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 2. 配置Python" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-2-%E9%85%8D%E7%BD%AEPython/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下 Python的安装配置</title>
    <link href="http://yoursite.com/2018/11/09/0202-os-linux/"/>
    <id>http://yoursite.com/2018/11/09/0202-os-linux/</id>
    <published>2018-11-09T07:11:08.000Z</published>
    <updated>2018-11-09T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><p>Python已经预装在大多数的Linux发行版本里。以Linux的发行版Ubuntu为例，在Ubuntu 16.04.3 LTS的版本里，同时预装了Python 2.7.12 和Python3.5.2 两个不同的版本。</p><p>在console<strong>终端</strong>里面键入：Python的话，系统会自动默认为需要启动Python2.7 如下图：</p><p><img src="/2018/11/09/0202-os-linux/640-20200708205720946.png" alt="img"></p><p>但是如果你需要启动指定的Python的话，可以键入”python2” 或者 “python2.7” 来启动Python2.7版本。或者可以键入”python3” 或者 “python3.5” 来启动Python3.5版本。如图：</p><p><img src="/2018/11/09/0202-os-linux/640-20200708205724297.jpeg" alt="img"></p><p>Linux 系统下的32bit和64bit的混合安装比较复杂，但是绝对可以实现的（亲测）。建议借助pyenv来管理Python的多版本安装。</p><p>需要指出的是：虽然Python 已经预装在Linux多数发行版本里，但是pip 即：Python的扩展库的管理程序却没有预装在系统里面，还是需要手动安装的。</p><p>以Ubuntu系统为例，可以在终端里面键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure><p>来安装pip。</p><p>或者从网站<a href="https://pip.pypa.io/en/stable/installing/下载**get-pip.py**的模块，然后在终端键入：" target="_blank" rel="noopener">https://pip.pypa.io/en/stable/installing/下载**get-pip.py**的模块，然后在终端键入：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure><p>来安装pip。 个人建议使用后者，这样pip里记录的第三方模块的信息会相对较新。否则可能还要手动更新记录才能安装第三方模块。</p><p>如有问题，欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 2. 配置Python" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-2-%E9%85%8D%E7%BD%AEPython/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统下 Python的安装配置</title>
    <link href="http://yoursite.com/2018/11/08/0201-os-windows/"/>
    <id>http://yoursite.com/2018/11/08/0201-os-windows/</id>
    <published>2018-11-08T07:11:08.000Z</published>
    <updated>2018-11-08T07:11:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><p>Python 解释器的安装是通过一个MSI安装（不是exe文件，exe可以作为安装文件，但更多的是作为可执行的程序，MSI才是标准的Windows安装引导文件）文件自动完成的。这个文件可以在Python的官方网站.<a href="https://www.python.org/downloads/下载，本文不在赘述。" target="_blank" rel="noopener">https://www.python.org/downloads/下载，本文不在赘述。</a></p><p>一般情况下，你下载的安装包是64bit的。在双击安装包之后，遇到安装程序的第一个界面时，如下图：</p><p><img src="/2018/11/08/0201-os-windows/0201-os-windows01.png" alt="avatar"></p><p>建议选择第二个，一是节省磁盘空间，而是在多用户电脑上不影响其他用户。</p><p>如果遇到选择安装路径界面的时候，如下图：</p><p><img src="/2018/11/08/0201-os-windows/0201-os-windows02.png" alt="avatar"></p><p>如果最终需要同时在该电脑上安装32bit的Python的话，我建议你将路径改为C:\Python27_X64\，未来来安装32bitPython的时候安装路径为：C:\Python27_X32 。</p><p>遇见安装选项界面的时候，如下图：</p><p><img src="/2018/11/08/0201-os-windows/640.jpeg" alt="img"></p><p>请勾选”pip”选项（pip 是Python的扩展包管理程序，就如同手机里的应用市场一样，用于管理Python模块：安装，升级或卸载）。</p><p>至于”Add python.exe to Path “，如果打算只安装一个Python版本，可以勾选。但是如果要安装不同版本，比如Python 32bit和64bit 的混合安装，建议这一步最后手动完成。</p><p>接下来的步骤就是”<strong>下一步”</strong>了。 直到安装引导程序运行完毕。 如果是需要64bit和32bit的Python混合安装，建议在C:\Python27_X64\目录下找到python.exe 和 pythonw.exe 两个可执行文件，<strong>复制**</strong>黏贴<strong>并</strong>重命名**在当前目录里，如下图：</p><p><img src="/2018/11/08/0201-os-windows/640-20200708152952042.png" alt="avatar"></p><p>同样在32bit的Python安装完之后，建议在C:\Python27_X32\目录下找到python.exe 和 pythonw.exe 两个可执行文件，只需要<strong>重命名</strong>所选文件在当前目录里，如下图：</p><p><img src="/2018/11/08/0201-os-windows/640-20200708152958583.png" alt="avatar"></p><p>如果是64bit和32bit同时安装在系统里面，那么就需要手动告知操作系统Python解释器的安装位置。在Windows 10 系统下:</p><blockquote><p>我的电脑-&gt;属性-&gt;高级-&gt;环境变量-&gt;系统变量</p></blockquote><p>中的找到名为PATH的系统环境变量: 将Python解释器的安装路径C:\Python27_X64 (或C:\Python27_X32\）添加在<strong>系统环境变量</strong>的PATH下。</p><ul><li>技巧1： 通过PowerShell 可以完成，打开PowerShell输入下面的命令：</li></ul><p>64bit 的Python:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Environment]::SetEnvironmentVariable(&quot;Path&quot;, &quot;$env:Path;C:\Python27_X64\;C:\Python27_X64\Scripts\&quot;, &quot;User&quot;)</span><br></pre></td></tr></table></figure><p>32bit 的Python：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Environment]::SetEnvironmentVariable(&quot;Path&quot;, &quot;$env:Path;C:\Python27_X32\;C:\Python27_X32\Scripts\&quot;, &quot;User&quot;)</span><br></pre></td></tr></table></figure><ul><li>技巧2， 或者通过CMD的命令来配置环境变量，如下：</li></ul><p>64bit 的Python:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;PATH;c:\python27_X64</span><br></pre></td></tr></table></figure><p>32bit 的Python:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;PATH;c:\python27_X32</span><br></pre></td></tr></table></figure><p>最后，检测Python是否成功安装。 打开命令提示符窗口，键入python (python指向默认的解释器即Python 64bit，或键入python64或python32)。 如果出现下面的情况：</p><p><img src="/2018/11/08/0201-os-windows/640-20200708153158201.jpeg" alt="avatar"></p><p>那么恭喜你安装成功。</p><p>但是如果出现下面的情况：</p><blockquote><p>‘python’不是内部或外部命令，也不是可运行的程序或批处理文件。</p></blockquote><p>就需要检查是不是<strong>系统环境变量</strong>里Python的<strong>安装路径</strong>是否正确。</p><p>如有问题，欢迎留言讨论.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 2. 配置Python" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-2-%E9%85%8D%E7%BD%AEPython/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python 开发环境与配置技巧</title>
    <link href="http://yoursite.com/2018/10/08/0102-development-and-configuration/"/>
    <id>http://yoursite.com/2018/10/08/0102-development-and-configuration/</id>
    <published>2018-10-08T03:27:20.000Z</published>
    <updated>2018-10-08T03:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者: Barbossa 公众号: <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzU3MTI2ODk0MA==#wechat_redirect" target="_blank" rel="noopener">巴博萨船长</a></p><p>Python的软件开发与其他编程语言例如C++/Java开发类似，开发环境的配置是前提。如何完成Python开发环境的搭建与搭建技巧，不同Python版本之间混合安装，比如3.0与2.x的混合安装或者32bit与64bit的混合安装，如何配置上述开发环境，今天就接着这篇文章给大家做个简单介绍。</p><h2 id="3-0还是2-7"><a href="#3-0还是2-7" class="headerlink" title="3.0还是2.7"></a><strong>3.0还是2.7</strong></h2><p>在之前的文章里解释了3.0和2.7的区别，<strong>两个版本并不兼容</strong>。3.0应该说是Python进化或改变的最终目标。因为大量的第三方库即支持模块都是以2.7</p><p>为基础完成的，而且Python的开源性，也就造成了代码维护和升级周期过长。所以建议还是从Python2.7学起。</p><h2 id="Python-开发环境与跨平台"><a href="#Python-开发环境与跨平台" class="headerlink" title="Python 开发环境与跨平台"></a><strong>Python 开发环境与跨平台</strong></h2><p>Python 是一种解释程序，也就是说编写的文本类py文件不是可执行文件如（如exe），是需要一个翻译者，翻译或者解释给计算机的。这里的翻译者就是Python解释器。Python的开发环境的配置也就是解释器的安装与配置。需要指出的是：Python解释器的代码与规范都是开源的，也就是说只要你水平够高，专业够硬就可以自己写Python解释器来运行你的Python代码。因为存在很多不同的Python解释器，所以我们这里解释器是<strong>标准的</strong>解释器。</p><p>Python支持跨平台开发，这里所说的跨平台是我们熟知Microsoft Windows， Linux （或Unix）或者Mac OS，而不是一些人理解的由移动设备如手机到PC的跨平台，也不是64bit和32bit的跨平台。这里要强调的是：一般情况下，Python的模块文件也就是后缀为py文件，可以用64bit的解释器或者32bit解释器运行。但编译过的文件，即后缀为pyc的文件却不行。</p><p>Python在不同系统下的环境配置与配置技巧，请查看该条公共消息的附属内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者: Barbossa 公众号: &lt;a href=&quot;https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzU3MTI2ODk0MA==#wechat_redirect&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="Python 相关 - 1. 关于Python" scheme="http://yoursite.com/categories/Python-%E7%9B%B8%E5%85%B3-1-%E5%85%B3%E4%BA%8EPython/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="开发环境" scheme="http://yoursite.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
